2025-03-04 07:18:49 - 
=== PROJECT STATEMENT ===
2025-03-04 07:18:49 - ---
description: About this project
globs:
---
# About this project

`twat-fs` is a file system utility library focused on robust and extensible file upload capabilities with multiple provider support. It provides:

- Multi-provider upload system with smart fallback (catbox.moe default, plus Dropbox, S3, etc.)
- Automatic retry for temporary failures, fallback for permanent ones
- URL validation and clean developer experience with type hints
- Simple CLI: `python -m twat_fs upload_file path/to/file.txt`
- Easy installation: `uv pip install twat-fs` (basic) or `uv pip install 'twat-fs[all,dev]'` (all features)

## Development Notes
- Uses `uv` for Python package management
- Quality tools: ruff, mypy, pytest
- Clear provider protocol for adding new storage backends
- Strong typing and runtime checks throughout

2025-03-04 07:18:49 - 
=== Current Status ===
2025-03-04 07:18:49 - Error: LOG.md is missing
2025-03-04 07:18:49 - [1.1K]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [3.4K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [  96]  .specstory
│   └── [ 288]  history
│       ├── [2.7K]  .what-is-this.md
│       ├── [146K]  2025-03-04_03-45-refining-todo-list-from-codebase-review.md
│       ├── [186K]  2025-03-04_04-43-incorporating-ideas-from-ideas-md-into-todo-md.md
│       ├── [164K]  2025-03-04_05-33-implementing-todo-phases-1,-2,-and-3.md
│       ├── [242K]  2025-03-04_06-19-implementation-of-todo-md-phases.md
│       ├── [4.2K]  2025-03-04_07-52-untitled.md
│       └── [ 40K]  2025-03-04_07-59-project-maintenance-and-documentation-update.md
├── [6.7K]  CHANGELOG.md
├── [ 986]  CLEANUP.txt
├── [ 56K]  IDEAS.md
├── [1.0K]  LICENSE
├── [ 153]  MANIFEST.in
├── [ 15K]  README.md
├── [370K]  REPO_CONTENT.txt
├── [3.4K]  TODO.md
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
├── [  96]  examples
│   └── [ 948]  upload_example.py
├── [ 439]  mypy.ini
├── [7.0K]  pyproject.toml
├── [ 128]  src
│   └── [ 384]  twat_fs
│       ├── [ 447]  __init__.py
│       ├── [ 733]  __main__.py
│       ├── [8.9K]  cli.py
│       ├── [ 128]  data
│       │   ├── [1.5K]  _test.jpg
│       │   └── [383K]  test.jpg
│       ├── [   1]  py.typed
│       ├── [ 25K]  upload.py
│       └── [ 704]  upload_providers
│           ├── [1.9K]  __init__.py
│           ├── [6.5K]  async_utils.py
│           ├── [5.5K]  bashupload.py
│           ├── [4.9K]  catbox.py
│           ├── [ 12K]  core.py
│           ├── [ 24K]  dropbox.py
│           ├── [5.4K]  factory.py
│           ├── [7.7K]  fal.py
│           ├── [6.7K]  filebin.py
│           ├── [ 11K]  litterbox.py
│           ├── [6.9K]  pixeldrain.py
│           ├── [3.9K]  protocols.py
│           ├── [ 10K]  s3.py
│           ├── [9.3K]  simple.py
│           ├── [ 728]  types.py
│           ├── [5.1K]  uguu.py
│           ├── [7.6K]  utils.py
│           └── [5.0K]  www0x0.py
├── [ 128]  templates
│   ├── [9.6K]  authenticated_provider_template.py
│   └── [6.5K]  simple_provider_template.py
├── [ 416]  tests
│   ├── [  63]  __init__.py
│   ├── [  96]  data
│   │   └── [ 100]  test.txt
│   ├── [8.6K]  test_async_utils.py
│   ├── [3.8K]  test_filebin_pixeldrain.py
│   ├── [9.0K]  test_integration.py
│   ├── [8.7K]  test_s3_advanced.py
│   ├── [ 180]  test_twat_fs.py
│   ├── [ 29K]  test_upload.py
│   └── [ 13K]  test_utils.py
├── [185K]  twat_search.txt
├── [2.8K]  update_providers.py
└── [383K]  uv.lock

17 directories, 67 files

2025-03-04 07:18:49 - 
Project structure:
2025-03-04 07:18:49 - [1.1K]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [3.4K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [  96]  .specstory
│   └── [ 288]  history
│       ├── [2.7K]  .what-is-this.md
│       ├── [146K]  2025-03-04_03-45-refining-todo-list-from-codebase-review.md
│       ├── [186K]  2025-03-04_04-43-incorporating-ideas-from-ideas-md-into-todo-md.md
│       ├── [164K]  2025-03-04_05-33-implementing-todo-phases-1,-2,-and-3.md
│       ├── [242K]  2025-03-04_06-19-implementation-of-todo-md-phases.md
│       ├── [4.2K]  2025-03-04_07-52-untitled.md
│       └── [ 40K]  2025-03-04_07-59-project-maintenance-and-documentation-update.md
├── [6.7K]  CHANGELOG.md
├── [ 986]  CLEANUP.txt
├── [ 56K]  IDEAS.md
├── [1.0K]  LICENSE
├── [ 153]  MANIFEST.in
├── [ 15K]  README.md
├── [370K]  REPO_CONTENT.txt
├── [3.4K]  TODO.md
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
├── [  96]  examples
│   └── [ 948]  upload_example.py
├── [ 439]  mypy.ini
├── [7.0K]  pyproject.toml
├── [ 128]  src
│   └── [ 384]  twat_fs
│       ├── [ 447]  __init__.py
│       ├── [ 733]  __main__.py
│       ├── [8.9K]  cli.py
│       ├── [ 128]  data
│       │   ├── [1.5K]  _test.jpg
│       │   └── [383K]  test.jpg
│       ├── [   1]  py.typed
│       ├── [ 25K]  upload.py
│       └── [ 704]  upload_providers
│           ├── [1.9K]  __init__.py
│           ├── [6.5K]  async_utils.py
│           ├── [5.5K]  bashupload.py
│           ├── [4.9K]  catbox.py
│           ├── [ 12K]  core.py
│           ├── [ 24K]  dropbox.py
│           ├── [5.4K]  factory.py
│           ├── [7.7K]  fal.py
│           ├── [6.7K]  filebin.py
│           ├── [ 11K]  litterbox.py
│           ├── [6.9K]  pixeldrain.py
│           ├── [3.9K]  protocols.py
│           ├── [ 10K]  s3.py
│           ├── [9.3K]  simple.py
│           ├── [ 728]  types.py
│           ├── [5.1K]  uguu.py
│           ├── [7.6K]  utils.py
│           └── [5.0K]  www0x0.py
├── [ 128]  templates
│   ├── [9.6K]  authenticated_provider_template.py
│   └── [6.5K]  simple_provider_template.py
├── [ 416]  tests
│   ├── [  63]  __init__.py
│   ├── [  96]  data
│   │   └── [ 100]  test.txt
│   ├── [8.6K]  test_async_utils.py
│   ├── [3.8K]  test_filebin_pixeldrain.py
│   ├── [9.0K]  test_integration.py
│   ├── [8.7K]  test_s3_advanced.py
│   ├── [ 180]  test_twat_fs.py
│   ├── [ 29K]  test_upload.py
│   └── [ 13K]  test_utils.py
├── [185K]  twat_search.txt
├── [2.8K]  update_providers.py
└── [383K]  uv.lock

17 directories, 67 files

2025-03-04 07:18:49 - On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   .specstory/history/2025-03-04_06-19-implementation-of-todo-md-phases.md
	modified:   CHANGELOG.md
	modified:   CLEANUP.txt
	modified:   README.md
	modified:   TODO.md
	modified:   cleanup.py
	modified:   src/twat_fs/upload_providers/async_utils.py
	modified:   tests/test_async_utils.py
	modified:   twat_search.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.specstory/history/2025-03-04_07-52-untitled.md
	.specstory/history/2025-03-04_07-59-project-maintenance-and-documentation-update.md
	REPO_CONTENT.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-03-04 07:18:49 - On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   .specstory/history/2025-03-04_06-19-implementation-of-todo-md-phases.md
	modified:   CHANGELOG.md
	modified:   CLEANUP.txt
	modified:   README.md
	modified:   TODO.md
	modified:   cleanup.py
	modified:   src/twat_fs/upload_providers/async_utils.py
	modified:   tests/test_async_utils.py
	modified:   twat_search.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.specstory/history/2025-03-04_07-52-untitled.md
	.specstory/history/2025-03-04_07-59-project-maintenance-and-documentation-update.md
	REPO_CONTENT.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-03-04 07:18:49 - 
=== Environment Status ===
2025-03-04 07:18:49 - Setting up virtual environment
2025-03-04 07:18:49 - Command failed: uv venv
2025-03-04 07:18:49 - Error: Using CPython 3.12.8 interpreter at: /Library/Frameworks/Python.framework/Versions/3.12/bin/python3.12
Creating virtual environment at: .venv
uv::venv::creation

  × Failed to create virtualenv
  ╰─▶ The directory `.venv` exists, but it's not a virtual environment

2025-03-04 07:18:49 - Failed to create virtual environment: Command '['uv', 'venv']' returned non-zero exit status 1.
2025-03-04 07:18:49 - Installing package with all extras
2025-03-04 07:18:49 - Setting up virtual environment
2025-03-04 07:18:49 - Command failed: uv venv
2025-03-04 07:18:49 - Error: Using CPython 3.12.8 interpreter at: /Library/Frameworks/Python.framework/Versions/3.12/bin/python3.12
Creating virtual environment at: .venv
uv::venv::creation

  × Failed to create virtualenv
  ╰─▶ The directory `.venv` exists, but it's not a virtual environment

2025-03-04 07:18:49 - Failed to create virtual environment: Command '['uv', 'venv']' returned non-zero exit status 1.
2025-03-04 07:18:49 - Command failed: uv pip install -e .[test,dev]
2025-03-04 07:18:49 - Error: error: Broken virtual environment `/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/.venv`: `pyvenv.cfg` is missing

2025-03-04 07:18:49 - Failed to install package: Command '['uv', 'pip', 'install', '-e', '.[test,dev]']' returned non-zero exit status 2.
2025-03-04 07:18:49 - Running code quality checks
2025-03-04 07:18:49 - >>> Running code fixes...
2025-03-04 07:18:50 - src/twat_fs/cli.py:61:9: C901 `status` is too complex (12 > 10)
   |
59 |     """Commands for managing upload providers."""
60 |
61 |     def status(self, provider_id: str | None = None, online: bool = False) -> None:
   |         ^^^^^^ C901
62 |         """
63 |         Show provider setup status.
   |

src/twat_fs/cli.py:61:9: PLR0912 Too many branches (15 > 12)
   |
59 |     """Commands for managing upload providers."""
60 |
61 |     def status(self, provider_id: str | None = None, online: bool = False) -> None:
   |         ^^^^^^ PLR0912
62 |         """
63 |         Show provider setup status.
   |

src/twat_fs/cli.py:61:9: PLR0915 Too many statements (52 > 50)
   |
59 |     """Commands for managing upload providers."""
60 |
61 |     def status(self, provider_id: str | None = None, online: bool = False) -> None:
   |         ^^^^^^ PLR0915
62 |         """
63 |         Show provider setup status.
   |

src/twat_fs/cli.py:61:54: FBT001 Boolean-typed positional argument in function definition
   |
59 |     """Commands for managing upload providers."""
60 |
61 |     def status(self, provider_id: str | None = None, online: bool = False) -> None:
   |                                                      ^^^^^^ FBT001
62 |         """
63 |         Show provider setup status.
   |

src/twat_fs/cli.py:61:54: FBT002 Boolean default positional argument in function definition
   |
59 |     """Commands for managing upload providers."""
60 |
61 |     def status(self, provider_id: str | None = None, online: bool = False) -> None:
   |                                                      ^^^^^^ FBT002
62 |         """
63 |         Show provider setup status.
   |

src/twat_fs/cli.py:137:21: PLW2901 `with` statement variable `status` overwritten by assignment target
    |
136 |                 for provider, info in sorted_providers:
137 |                     status = (
    |                     ^^^^^^ PLW2901
138 |                         "[green]Ready[/green]"
139 |                         if info.success
    |

src/twat_fs/cli.py:162:20: FBT001 Boolean-typed positional argument in function definition
    |
160 |             console.print(table)
161 |
162 |     def list(self, online: bool = False) -> None:
    |                    ^^^^^^ FBT001
163 |         """List all available (ready) provider IDs, one per line. If --online is provided, run online tests.
164 |         In online mode, reconfigure logger so that info messages are printed to stderr."""
    |

src/twat_fs/cli.py:162:20: FBT002 Boolean default positional argument in function definition
    |
160 |             console.print(table)
161 |
162 |     def list(self, online: bool = False) -> None:
    |                    ^^^^^^ FBT002
163 |         """List all available (ready) provider IDs, one per line. If --online is provided, run online tests.
164 |         In online mode, reconfigure logger so that info messages are printed to stderr."""
    |

src/twat_fs/cli.py:180:13: B007 Loop control variable `provider` not used within loop body
    |
179 |         # Print each active provider ID, one per line, to stdout
180 |         for provider in active_providers:
    |             ^^^^^^^^ B007
181 |             pass
    |
    = help: Rename unused `provider` to `_provider`

src/twat_fs/cli.py:198:9: PLR0913 Too many arguments in function definition (6 > 5)
    |
196 |         self.upload_provider = UploadProviderCommands()
197 |
198 |     def upload(
    |         ^^^^^^ PLR0913
199 |         self,
200 |         file_path: str | Path,
    |

src/twat_fs/cli.py:202:9: FBT001 Boolean-typed positional argument in function definition
    |
200 |         file_path: str | Path,
201 |         provider: str | list[str] = PROVIDERS_PREFERENCE,
202 |         unique: bool = False,
    |         ^^^^^^ FBT001
203 |         force: bool = False,
204 |         remote_path: str | None = None,
    |

src/twat_fs/cli.py:202:9: FBT002 Boolean default positional argument in function definition
    |
200 |         file_path: str | Path,
201 |         provider: str | list[str] = PROVIDERS_PREFERENCE,
202 |         unique: bool = False,
    |         ^^^^^^ FBT002
203 |         force: bool = False,
204 |         remote_path: str | None = None,
    |

src/twat_fs/cli.py:203:9: FBT001 Boolean-typed positional argument in function definition
    |
201 |         provider: str | list[str] = PROVIDERS_PREFERENCE,
202 |         unique: bool = False,
203 |         force: bool = False,
    |         ^^^^^ FBT001
204 |         remote_path: str | None = None,
205 |         fragile: bool = False,
    |

src/twat_fs/cli.py:203:9: FBT002 Boolean default positional argument in function definition
    |
201 |         provider: str | list[str] = PROVIDERS_PREFERENCE,
202 |         unique: bool = False,
203 |         force: bool = False,
    |         ^^^^^ FBT002
204 |         remote_path: str | None = None,
205 |         fragile: bool = False,
    |

src/twat_fs/cli.py:205:9: FBT001 Boolean-typed positional argument in function definition
    |
203 |         force: bool = False,
204 |         remote_path: str | None = None,
205 |         fragile: bool = False,
    |         ^^^^^^^ FBT001
206 |     ) -> str:
207 |         """
    |

src/twat_fs/cli.py:205:9: FBT002 Boolean default positional argument in function definition
    |
203 |         force: bool = False,
204 |         remote_path: str | None = None,
205 |         fragile: bool = False,
    |         ^^^^^^^ FBT002
206 |     ) -> str:
207 |         """
    |

src/twat_fs/upload.py:57:5: C901 `_test_provider_online` is too complex (19 > 10)
   |
57 | def _test_provider_online(
   |     ^^^^^^^^^^^^^^^^^^^^^ C901
58 |     provider_name: str,
59 | ) -> tuple[bool, str, dict[str, float] | None]:
   |

src/twat_fs/upload.py:57:5: PLR0911 Too many return statements (11 > 6)
   |
57 | def _test_provider_online(
   |     ^^^^^^^^^^^^^^^^^^^^^ PLR0911
58 |     provider_name: str,
59 | ) -> tuple[bool, str, dict[str, float] | None]:
   |

src/twat_fs/upload.py:57:5: PLR0912 Too many branches (21 > 12)
   |
57 | def _test_provider_online(
   |     ^^^^^^^^^^^^^^^^^^^^^ PLR0912
58 |     provider_name: str,
59 | ) -> tuple[bool, str, dict[str, float] | None]:
   |

src/twat_fs/upload.py:57:5: PLR0915 Too many statements (73 > 50)
   |
57 | def _test_provider_online(
   |     ^^^^^^^^^^^^^^^^^^^^^ PLR0915
58 |     provider_name: str,
59 | ) -> tuple[bool, str, dict[str, float] | None]:
   |

src/twat_fs/upload.py:250:5: C901 `setup_provider` is too complex (13 > 10)
    |
250 | def setup_provider(
    |     ^^^^^^^^^^^^^^ C901
251 |     provider: str, verbose: bool = False, online: bool = False
252 | ) -> ProviderInfo:
    |

src/twat_fs/upload.py:250:5: PLR0911 Too many return statements (7 > 6)
    |
250 | def setup_provider(
    |     ^^^^^^^^^^^^^^ PLR0911
251 |     provider: str, verbose: bool = False, online: bool = False
252 | ) -> ProviderInfo:
    |

src/twat_fs/upload.py:250:5: PLR0912 Too many branches (14 > 12)
    |
250 | def setup_provider(
    |     ^^^^^^^^^^^^^^ PLR0912
251 |     provider: str, verbose: bool = False, online: bool = False
252 | ) -> ProviderInfo:
    |

src/twat_fs/upload.py:251:20: FBT001 Boolean-typed positional argument in function definition
    |
250 | def setup_provider(
251 |     provider: str, verbose: bool = False, online: bool = False
    |                    ^^^^^^^ FBT001
252 | ) -> ProviderInfo:
253 |     """
    |

src/twat_fs/upload.py:251:20: FBT002 Boolean default positional argument in function definition
    |
250 | def setup_provider(
251 |     provider: str, verbose: bool = False, online: bool = False
    |                    ^^^^^^^ FBT002
252 | ) -> ProviderInfo:
253 |     """
    |

src/twat_fs/upload.py:251:43: FBT001 Boolean-typed positional argument in function definition
    |
250 | def setup_provider(
251 |     provider: str, verbose: bool = False, online: bool = False
    |                                           ^^^^^^ FBT001
252 | ) -> ProviderInfo:
253 |     """
    |

src/twat_fs/upload.py:251:43: FBT002 Boolean default positional argument in function definition
    |
250 | def setup_provider(
251 |     provider: str, verbose: bool = False, online: bool = False
    |                                           ^^^^^^ FBT002
252 | ) -> ProviderInfo:
253 |     """
    |

src/twat_fs/upload.py:268:17: FBT003 Boolean positional value in function call
    |
266 |         if provider.lower() == "simple":
267 |             return ProviderInfo(
268 |                 False,
    |                 ^^^^^ FBT003
269 |                 f"Provider '{provider}' is not available.",
270 |                 {},
    |

src/twat_fs/upload.py:279:21: FBT003 Boolean positional value in function call
    |
277 |             if not help_info:
278 |                 return ProviderInfo(
279 |                     False,
    |                     ^^^^^ FBT003
280 |                     f"Provider '{provider}' is not available.",
281 |                     {},
    |

src/twat_fs/upload.py:285:17: FBT003 Boolean positional value in function call
    |
283 |             setup_info = help_info.get("setup", "")
284 |             return ProviderInfo(
285 |                 False,
    |                 ^^^^^ FBT003
286 |                 f"Provider '{provider}' is not available.",
287 |                 {"setup": setup_info},
    |

src/twat_fs/upload.py:306:21: FBT003 Boolean positional value in function call
    |
304 |                 setup_info = help_info.get("setup", "") if help_info else ""
305 |                 return ProviderInfo(
306 |                     False,
    |                     ^^^^^ FBT003
307 |                     f"Provider '{provider}' needs configuration.",
308 |                     {"setup": setup_info},
    |

src/twat_fs/upload.py:329:21: FBT003 Boolean positional value in function call
    |
327 |             if (has_async and has_sync) or has_sync:
328 |                 provider_info = ProviderInfo(
329 |                     True,
    |                     ^^^^ FBT003
330 |                     f"{provider} ({type(client).__name__})"
331 |                     + (f" - {retention_note}" if retention_note else ""),
    |

src/twat_fs/upload.py:337:21: FBT003 Boolean positional value in function call
    |
335 |                 setup_info = help_info.get("setup", "") if help_info else ""
336 |                 provider_info = ProviderInfo(
337 |                     False,
    |                     ^^^^^ FBT003
338 |                     f"Provider '{provider}' needs configuration.",
339 |                     {"setup": setup_info},
    |

src/twat_fs/upload.py:346:25: FBT003 Boolean positional value in function call
    |
344 |                 if not online_status:
345 |                     provider_info = ProviderInfo(
346 |                         False,
    |                         ^^^^^ FBT003
347 |                         message,
348 |                         provider_info.help_info,
    |

src/twat_fs/upload.py:366:17: FBT003 Boolean positional value in function call
    |
364 |             setup_info = help_info.get("setup", "") if help_info else ""
365 |             return ProviderInfo(
366 |                 False,
    |                 ^^^^^ FBT003
367 |                 f"Provider '{provider}' setup failed: {e}",
368 |                 {"setup": setup_info},
    |

src/twat_fs/upload.py:374:13: FBT003 Boolean positional value in function call
    |
372 |         logger.error(f"Unexpected error setting up provider {provider}: {e}")
373 |         return ProviderInfo(
374 |             False,
    |             ^^^^^ FBT003
375 |             f"Provider '{provider}' failed: {e}",
376 |             {},
    |

src/twat_fs/upload.py:381:5: FBT001 Boolean-typed positional argument in function definition
    |
380 | def setup_providers(
381 |     verbose: bool = False, online: bool = False
    |     ^^^^^^^ FBT001
382 | ) -> dict[str, ProviderInfo]:
383 |     """
    |

src/twat_fs/upload.py:381:5: FBT002 Boolean default positional argument in function definition
    |
380 | def setup_providers(
381 |     verbose: bool = False, online: bool = False
    |     ^^^^^^^ FBT002
382 | ) -> dict[str, ProviderInfo]:
383 |     """
    |

src/twat_fs/upload.py:381:28: FBT001 Boolean-typed positional argument in function definition
    |
380 | def setup_providers(
381 |     verbose: bool = False, online: bool = False
    |                            ^^^^^^ FBT001
382 | ) -> dict[str, ProviderInfo]:
383 |     """
    |

src/twat_fs/upload.py:381:28: FBT002 Boolean default positional argument in function definition
    |
380 | def setup_providers(
381 |     verbose: bool = False, online: bool = False
    |                            ^^^^^^ FBT002
382 | ) -> dict[str, ProviderInfo]:
383 |     """
    |

src/twat_fs/upload.py:411:5: PLR0913 Too many arguments in function definition (6 > 5)
    |
411 | def _try_upload_with_provider(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
412 |     provider_name: str,
413 |     file_path: str | Path,
    |

src/twat_fs/upload.py:550:5: PLR0913 Too many arguments in function definition (8 > 5)
    |
550 | def _try_next_provider(
    |     ^^^^^^^^^^^^^^^^^^ PLR0913
551 |     remaining_providers: Sequence[str],
552 |     file_path: str | Path,
    |

src/twat_fs/upload.py:619:5: PLR0913 Too many arguments in function definition (7 > 5)
    |
617 |     exceptions=(RetryableError,),  # Only retry on RetryableError
618 | )
619 | def upload_file(
    |     ^^^^^^^^^^^ PLR0913
620 |     file_path: str | Path,
621 |     provider: str | Sequence[str] | None = None,
    |

src/twat_fs/upload.py:687:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
685 |         if fragile or len(providers) == 1:
686 |             msg = f"Provider {providers[0]} failed: {e}"
687 |             raise NonRetryableError(msg, providers[0])
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
688 |
689 |         # Try remaining providers with circular fallback
    |

src/twat_fs/upload.py:703:5: PLR0913 Too many arguments in function definition (7 > 5)
    |
703 | def _try_upload_with_fallback(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
704 |     provider: str,
705 |     local_path: str | Path,
    |

src/twat_fs/upload_providers/__init__.py:11:20: F401 `loguru.logger` imported but unused
   |
 9 | from typing import TYPE_CHECKING
10 |
11 | from loguru import logger
   |                    ^^^^^^ F401
12 |
13 | from twat_fs.upload_providers.core import RetryableError, NonRetryableError, UploadError
   |
   = help: Remove unused import: `loguru.logger`

src/twat_fs/upload_providers/__init__.py:19:25: F401 `pathlib.Path` imported but unused
   |
18 | if TYPE_CHECKING:
19 |     from pathlib import Path
   |                         ^^^^ F401
20 |
21 | # List of available providers in order of preference
   |
   = help: Remove unused import: `pathlib.Path`

src/twat_fs/upload_providers/core.py:168:13: S101 Use of `assert` detected
    |
166 |                     time.sleep(delay)
167 |
168 |             assert last_exception is not None  # for type checker
    |             ^^^^^^ S101
169 |             raise last_exception
    |

src/twat_fs/upload_providers/core.py:214:13: S101 Use of `assert` detected
    |
212 |                     await asyncio.sleep(delay)
213 |
214 |             assert last_exception is not None  # for type checker
    |             ^^^^^^ S101
215 |             raise last_exception
    |

src/twat_fs/upload_providers/dropbox.py:124:11: ARG002 Unused method argument: `kwargs`
    |
122 |         unique: bool = False,
123 |         upload_path: str | None = DEFAULT_UPLOAD_PATH,
124 |         **kwargs: Any,
    |           ^^^^^^ ARG002
125 |     ) -> UploadResult:
126 |         """
    |

src/twat_fs/upload_providers/fal.py:51:25: RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   |
50 |     # Environment variables
51 |     REQUIRED_ENV_VARS = ["FAL_KEY"]
   |                         ^^^^^^^^^^^ RUF012
52 |     OPTIONAL_ENV_VARS: list[str] = []
   |

src/twat_fs/upload_providers/fal.py:52:36: RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   |
50 |     # Environment variables
51 |     REQUIRED_ENV_VARS = ["FAL_KEY"]
52 |     OPTIONAL_ENV_VARS: list[str] = []
   |                                    ^^ RUF012
53 |
54 |     def __init__(self, key: str) -> None:
   |

src/twat_fs/upload_providers/fal.py:67:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
65 |             logger.error(f"Failed to create FAL client: {e}")
66 |             msg = f"Failed to create FAL client: {e}"
67 |             raise NonRetryableError(msg, self.provider_name)
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
68 |
69 |     @classmethod
   |

src/twat_fs/upload_providers/litterbox.py:223:9: PLR0913 Too many arguments in function definition (6 > 5)
    |
221 |             raise
222 |
223 |     def upload_file(
    |         ^^^^^^^^^^^ PLR0913
224 |         self,
225 |         local_path: str | Path,
    |

src/twat_fs/upload_providers/litterbox.py:300:5: PLR0913 Too many arguments in function definition (6 > 5)
    |
300 | def upload_file(
    |     ^^^^^^^^^^^ PLR0913
301 |     local_path: str | Path,
302 |     remote_path: str | Path | None = None,
    |

src/twat_fs/upload_providers/s3.py:182:11: ARG002 Unused method argument: `kwargs`
    |
180 |         file: BinaryIO,
181 |         remote_path: str | Path | None = None,
182 |         **kwargs: Any,
    |           ^^^^^^ ARG002
183 |     ) -> UploadResult:
184 |         """
    |

src/twat_fs/upload_providers/simple.py:78:9: ARG002 Unused method argument: `remote_path`
   |
76 |         self,
77 |         local_path: str | Path,
78 |         remote_path: str | Path | None = None,
   |         ^^^^^^^^^^^ ARG002
79 |         *,
80 |         unique: bool = False,
   |

src/twat_fs/upload_providers/simple.py:80:9: ARG002 Unused method argument: `unique`
   |
78 |         remote_path: str | Path | None = None,
79 |         *,
80 |         unique: bool = False,
   |         ^^^^^^ ARG002
81 |         force: bool = False,
82 |         upload_path: str | None = None,
   |

src/twat_fs/upload_providers/simple.py:81:9: ARG002 Unused method argument: `force`
   |
79 |         *,
80 |         unique: bool = False,
81 |         force: bool = False,
   |         ^^^^^ ARG002
82 |         upload_path: str | None = None,
83 |         **kwargs: Any,
   |

src/twat_fs/upload_providers/simple.py:82:9: ARG002 Unused method argument: `upload_path`
   |
80 |         unique: bool = False,
81 |         force: bool = False,
82 |         upload_path: str | None = None,
   |         ^^^^^^^^^^^ ARG002
83 |         **kwargs: Any,
84 |     ) -> UploadResult:
   |

src/twat_fs/upload_providers/simple.py:83:11: ARG002 Unused method argument: `kwargs`
   |
81 |         force: bool = False,
82 |         upload_path: str | None = None,
83 |         **kwargs: Any,
   |           ^^^^^^ ARG002
84 |     ) -> UploadResult:
85 |         """
   |

src/twat_fs/upload_providers/simple.py:123:9: ARG002 Unused method argument: `remote_path`
    |
121 |         self,
122 |         file_path: str | Path,
123 |         remote_path: str | Path | None = None,
    |         ^^^^^^^^^^^ ARG002
124 |         *,
125 |         unique: bool = False,
    |

src/twat_fs/upload_providers/simple.py:125:9: ARG002 Unused method argument: `unique`
    |
123 |         remote_path: str | Path | None = None,
124 |         *,
125 |         unique: bool = False,
    |         ^^^^^^ ARG002
126 |         force: bool = False,
127 |         upload_path: str | None = None,
    |

src/twat_fs/upload_providers/simple.py:126:9: ARG002 Unused method argument: `force`
    |
124 |         *,
125 |         unique: bool = False,
126 |         force: bool = False,
    |         ^^^^^ ARG002
127 |         upload_path: str | None = None,
128 |         **kwargs: Any,
    |

src/twat_fs/upload_providers/simple.py:127:9: ARG002 Unused method argument: `upload_path`
    |
125 |         unique: bool = False,
126 |         force: bool = False,
127 |         upload_path: str | None = None,
    |         ^^^^^^^^^^^ ARG002
128 |         **kwargs: Any,
129 |     ) -> Coroutine[Any, Any, UploadResult]:
    |

src/twat_fs/upload_providers/simple.py:128:11: ARG002 Unused method argument: `kwargs`
    |
126 |         force: bool = False,
127 |         upload_path: str | None = None,
128 |         **kwargs: Any,
    |           ^^^^^^ ARG002
129 |     ) -> Coroutine[Any, Any, UploadResult]:
130 |         """
    |

src/twat_fs/upload_providers/types.py:1:1: A005 Module `types` shadows a Python standard-library module
src/twat_fs/upload_providers/utils.py:251:5: FBT001 Boolean-typed positional argument in function definition
    |
249 |     provider_name: str,
250 |     file_path: str | Path,
251 |     success: bool,
    |     ^^^^^^^ FBT001
252 |     error: Exception | None = None,
253 | ) -> None:
    |

tests/test_s3_advanced.py:21:19: S105 Possible hardcoded password assigned to: "TEST_SECRET_KEY"
   |
19 | TEST_BUCKET = "test-bucket"
20 | TEST_ACCESS_KEY = "test_key"
21 | TEST_SECRET_KEY = "test_secret"
   |                   ^^^^^^^^^^^^^ S105
22 |
23 | # Test data
   |

tests/test_upload.py:351:9: ARG002 Unused method argument: `mock_dropbox_provider`
    |
349 |         test_file: Path,
350 |         mock_s3_provider: MagicMock,
351 |         mock_dropbox_provider: MagicMock,
    |         ^^^^^^^^^^^^^^^^^^^^^ ARG002
352 |     ) -> None:
353 |         """Test fallback to next provider on auth failure."""
    |

tests/test_utils.py:104:55: ARG002 Unused method argument: `mock_access`
    |
103 |     @mock.patch("os.access", return_value=False)
104 |     def test_validate_file_with_unreadable_file(self, mock_access):
    |                                                       ^^^^^^^^^^^ ARG002
105 |         """Test that validate_file raises PermissionError for unreadable files."""
106 |         with tempfile.NamedTemporaryFile(delete=False) as temp_file:
    |

tests/test_utils.py:340:62: FBT003 Boolean positional value in function call
    |
338 |     def test_log_upload_attempt_success(self, mock_logger_info):
339 |         """Test that log_upload_attempt logs success correctly."""
340 |         log_upload_attempt("test_provider", "test_file.txt", True)
    |                                                              ^^^^ FBT003
341 |
342 |         mock_logger_info.assert_called_once()
    |

tests/test_utils.py:349:62: FBT003 Boolean positional value in function call
    |
347 |         """Test that log_upload_attempt logs failure correctly."""
348 |         error = Exception("Test error")
349 |         log_upload_attempt("test_provider", "test_file.txt", False, error)
    |                                                              ^^^^^ FBT003
350 |
351 |         mock_logger_error.assert_called_once()
    |

Found 73 errors.

2025-03-04 07:18:51 - 30 files left unchanged

2025-03-04 07:18:51 - >>>Running type checks...
2025-03-04 07:19:34 - src/twat_fs/upload_providers/factory.py:105: error: Incompatible types in assignment (expression has type Module, variable has type "Provider | None")  [assignment]
src/twat_fs/upload_providers/async_utils.py:197: error: Returning Any from function declared to return "list[T_co | BaseException]"  [no-any-return]
src/twat_fs/upload_providers/simple.py:118: error: Argument 1 to "with_url_validation" has incompatible type "Callable[[BaseProvider, str | Path, str | Path | None, DefaultNamedArg(bool, 'unique'), DefaultNamedArg(bool, 'force'), DefaultNamedArg(str | None, 'upload_path'), KwArg(Any)], Awaitable[Coroutine[Any, Any, UploadResult]]]"; expected "Callable[[BaseProvider, str | Path, str | Path | None, DefaultNamedArg(bool, 'unique'), DefaultNamedArg(bool, 'force'), DefaultNamedArg(str | None, 'upload_path'), KwArg(Any)], Awaitable[str | UploadResult]]"  [arg-type]
src/twat_fs/upload_providers/simple.py:120: error: Return type "Awaitable[UploadResult]" of "async_upload_file" incompatible with return type "Coroutine[Any, Any, Coroutine[Any, Any, UploadResult]]" in supertype "Provider"  [override]
src/twat_fs/upload_providers/simple.py:156: error: Incompatible return value type (got "UploadResult", expected "Coroutine[Any, Any, UploadResult]")  [return-value]
src/twat_fs/upload_providers/simple.py:237: error: Need type annotation for "sync_upload"  [var-annotated]
src/twat_fs/upload_providers/simple.py:237: error: Argument 1 to "to_sync" has incompatible type "Callable[[str | Path, str | Path | None, DefaultNamedArg(bool, 'unique'), DefaultNamedArg(bool, 'force'), DefaultNamedArg(str | None, 'upload_path'), KwArg(Any)], Awaitable[UploadResult]]"; expected "Callable[[str | Path, str | Path | None, DefaultNamedArg(bool, 'unique'), DefaultNamedArg(bool, 'force'), DefaultNamedArg(str | None, 'upload_path'), KwArg(Any)], Coroutine[Any, Any, Never]]"  [arg-type]
src/twat_fs/upload_providers/simple.py:238: error: Returning Any from function declared to return "UploadResult"  [no-any-return]
src/twat_fs/upload_providers/simple.py:261: error: Need type annotation for "sync_upload"  [var-annotated]
src/twat_fs/upload_providers/simple.py:261: error: Argument 1 to "to_sync" has incompatible type "Callable[[str | Path, str | Path | None, DefaultNamedArg(bool, 'unique'), DefaultNamedArg(bool, 'force'), DefaultNamedArg(str | None, 'upload_path'), KwArg(Any)], Awaitable[UploadResult]]"; expected "Callable[[str | Path, str | Path | None, DefaultNamedArg(bool, 'unique'), DefaultNamedArg(bool, 'force'), DefaultNamedArg(str | None, 'upload_path'), KwArg(Any)], Coroutine[Any, Any, Never]]"  [arg-type]
src/twat_fs/upload_providers/simple.py:262: error: Returning Any from function declared to return "UploadResult"  [no-any-return]
src/twat_fs/upload_providers/simple.py:273: error: Return type "Coroutine[Any, Any, UploadResult]" of "async_upload_file" incompatible with return type "Coroutine[Any, Any, Coroutine[Any, Any, UploadResult]]" in supertype "Provider"  [override]
src/twat_fs/upload_providers/uguu.py:71: error: Returning Any from function declared to return "str"  [no-any-return]
src/twat_fs/upload_providers/litterbox.py:48: error: Cannot override instance variable (previously declared on base class "Provider") with class variable  [misc]
src/twat_fs/upload_providers/s3.py:62: error: Cannot override instance variable (previously declared on base class "Provider") with class variable  [misc]
src/twat_fs/upload_providers/s3.py:87: error: Cannot assign to class variable "provider_name" via instance  [misc]
src/twat_fs/cli.py:138: error: Incompatible types in assignment (expression has type "str", variable has type "Status")  [assignment]
src/twat_fs/cli.py:147: error: Incompatible types in assignment (expression has type "str", variable has type "float")  [assignment]
src/twat_fs/cli.py:152: error: Incompatible types in assignment (expression has type "str", variable has type "float")  [assignment]
src/twat_fs/cli.py:157: error: Argument 1 to "add_row" of "Table" has incompatible type "*list[object]"; expected "ConsoleRenderable | RichCast | str | None"  [arg-type]
Found 20 errors in 7 files (checked 31 source files)

2025-03-04 07:19:34 - >>> Running tests...
2025-03-04 07:21:06 - ============================= test session starts ==============================
platform darwin -- Python 3.12.8, pytest-8.3.4, pluggy-1.5.0 -- /usr/local/bin/python
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/.hypothesis/examples'))
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
Fugue tests will be initialized with options:
rootdir: /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs
configfile: pyproject.toml
plugins: recording-0.13.2, jaxtyping-0.2.37, cov-6.0.0, flake8-1.3.0, subtests-0.14.1, instafail-0.5.0, docker-3.1.2, jaraco.mongodb-12.1.2, enabler-3.3.0, ignore-flaky-2.2.1, integration-0.2.3, sugar-1.0.0, langchain-0.1.0, env-1.1.5, socket-0.7.0, flaky-3.8.1, time-machine-2.16.0, shutil-1.8.1, asyncio-0.25.3, checkdocs-2.13.0, hypothesis-6.124.7, black-0.6.0, anyio-4.8.0, darkgraylib-1.2.1, ruff-0.4.1, benchmark-5.1.0, pmxbot-1122.17.0, virtualenv-1.8.1, jaraco.vcs-2.4.0, perf-0.15.0, rerunfailures-15.0, fugue-0.9.2.dev1, timeout-2.3.1, mock-3.14.0, typeguard-4.4.2, logfire-3.4.0, dash-2.18.2, xdist-3.6.1, depends-1.0.1, requests-mock-1.12.1, syrupy-4.8.1
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=function
created: 8/8 workers
8 workers [150 items]

scheduling tests via LoadScheduling

tests/__init__.py::ruff 
tests/test_async_utils.py::ruff::format 
tests/test_async_utils.py::TestRunAsync::test_run_async_with_existing_event_loop 
tests/test_async_utils.py::TestToSync::test_to_sync_preserves_arguments 
tests/test_async_utils.py::TestWithAsyncTimeout::test_with_async_timeout_success 
tests/test_async_utils.py::TestToAsync::test_to_async_preserves_arguments 
tests/test_filebin_pixeldrain.py::ruff::format 
tests/test_filebin_pixeldrain.py::test_pixeldrain_upload_success 
[gw3] [  0%] PASSED tests/test_async_utils.py::TestToSync::test_to_sync_preserves_arguments 
[gw4] [  1%] PASSED tests/test_async_utils.py::TestToAsync::test_to_async_preserves_arguments 
[gw2] [  2%] PASSED tests/test_async_utils.py::TestRunAsync::test_run_async_with_existing_event_loop 
tests/test_async_utils.py::TestToAsync::test_to_async_with_direct_decoration 
tests/test_async_utils.py::TestGatherWithConcurrency::test_gather_with_concurrency 
[gw3] [  2%] PASSED tests/test_async_utils.py::TestToAsync::test_to_async_with_direct_decoration 
tests/test_async_utils.py::TestToSync::test_to_sync_with_direct_decoration 
[gw7] [  3%] PASSED tests/test_filebin_pixeldrain.py::test_pixeldrain_upload_success 
[gw2] [  4%] PASSED tests/test_async_utils.py::TestToSync::test_to_sync_with_direct_decoration 
tests/test_async_utils.py::TestToAsync::test_to_async_with_arguments 
[gw3] [  4%] PASSED tests/test_async_utils.py::TestToAsync::test_to_async_with_arguments 
[gw1] [  5%] PASSED tests/test_async_utils.py::ruff::format 
tests/test_filebin_pixeldrain.py::test_pixeldrain_upload_failure 
tests/test_async_utils.py::TestToSync::test_to_sync_with_arguments 
[gw0] [  6%] PASSED tests/__init__.py::ruff 
[gw6] [  6%] PASSED tests/test_filebin_pixeldrain.py::ruff::format 
[gw2] [  7%] PASSED tests/test_async_utils.py::TestToSync::test_to_sync_with_arguments 
tests/test_async_utils.py::TestToAsync::test_to_async_preserves_docstring 
[gw3] [  8%] PASSED tests/test_async_utils.py::TestToAsync::test_to_async_preserves_docstring 
tests/test_async_utils.py::black 
tests/__init__.py::ruff::format 
[gw5] [  8%] PASSED tests/test_async_utils.py::TestWithAsyncTimeout::test_with_async_timeout_success 
tests/test_async_utils.py::TestToSync::test_to_sync_preserves_docstring 
tests/test_filebin_pixeldrain.py::black 
[gw2] [  9%] PASSED tests/test_async_utils.py::TestToSync::test_to_sync_preserves_docstring 
tests/test_integration.py::ruff 
tests/test_async_utils.py::TestWithAsyncTimeout::test_with_async_timeout_timeout 
tests/test_integration.py::TestS3Integration::test_s3_upload_large_file 
[gw0] [ 10%] PASSED tests/__init__.py::ruff::format 
[gw3] [ 10%] PASSED tests/test_integration.py::ruff 
tests/__init__.py::black 
tests/test_integration.py::ruff::format 
[gw5] [ 11%] PASSED tests/test_async_utils.py::TestWithAsyncTimeout::test_with_async_timeout_timeout 
tests/test_async_utils.py::TestWithAsyncTimeout::test_with_async_timeout_preserves_metadata 
[gw3] [ 12%] PASSED tests/test_integration.py::ruff::format 
tests/test_integration.py::black 
[gw2] [ 12%] SKIPPED tests/test_integration.py::TestS3Integration::test_s3_upload_large_file 
tests/test_integration.py::TestS3Integration::test_s3_upload_with_custom_endpoint 
[gw2] [ 13%] SKIPPED tests/test_integration.py::TestS3Integration::test_s3_upload_with_custom_endpoint 
tests/test_integration.py::TestDropboxIntegration::test_dropbox_setup 
[gw5] [ 14%] PASSED tests/test_async_utils.py::TestWithAsyncTimeout::test_with_async_timeout_preserves_metadata 
tests/test_filebin_pixeldrain.py::ruff 
[gw4] [ 14%] PASSED tests/test_async_utils.py::TestGatherWithConcurrency::test_gather_with_concurrency 
tests/test_async_utils.py::TestGatherWithConcurrency::test_gather_with_concurrency_with_exceptions 
[gw5] [ 15%] PASSED tests/test_filebin_pixeldrain.py::ruff 
[gw4] [ 16%] PASSED tests/test_async_utils.py::TestGatherWithConcurrency::test_gather_with_concurrency_with_exceptions 
tests/test_integration.py::TestCatboxIntegration::test_catbox_setup 
tests/test_async_utils.py::TestAsyncContextManager::test_async_context_manager 
[gw4] [ 16%] PASSED tests/test_async_utils.py::TestAsyncContextManager::test_async_context_manager 
tests/test_integration.py::TestLitterboxIntegration::test_litterbox_upload_small_file 
[gw4] [ 17%] ERROR tests/test_integration.py::TestLitterboxIntegration::test_litterbox_upload_small_file 
tests/test_integration.py::TestLitterboxIntegration::test_litterbox_upload_large_file 
[gw4] [ 18%] ERROR tests/test_integration.py::TestLitterboxIntegration::test_litterbox_upload_large_file 
tests/test_integration.py::TestLitterboxIntegration::test_litterbox_different_expirations 
[gw4] [ 18%] ERROR tests/test_integration.py::TestLitterboxIntegration::test_litterbox_different_expirations 
tests/test_s3_advanced.py::ruff 
[gw5] [ 19%] FAILED tests/test_integration.py::TestCatboxIntegration::test_catbox_setup 
tests/test_integration.py::TestCatboxIntegration::test_catbox_upload_small_file 
[gw5] [ 20%] ERROR tests/test_integration.py::TestCatboxIntegration::test_catbox_upload_small_file 
tests/test_integration.py::TestCatboxIntegration::test_catbox_upload_large_file 
[gw5] [ 20%] ERROR tests/test_integration.py::TestCatboxIntegration::test_catbox_upload_large_file 
tests/test_integration.py::TestCatboxIntegration::test_catbox_authenticated_upload 
[gw5] [ 21%] SKIPPED tests/test_integration.py::TestCatboxIntegration::test_catbox_authenticated_upload 
tests/test_integration.py::TestLitterboxIntegration::test_litterbox_setup 
[gw5] [ 22%] FAILED tests/test_integration.py::TestLitterboxIntegration::test_litterbox_setup 
tests/test_s3_advanced.py::black 
[gw4] [ 22%] FAILED tests/test_s3_advanced.py::ruff 
tests/test_s3_advanced.py::ruff::format 
[gw4] [ 23%] PASSED tests/test_s3_advanced.py::ruff::format 
tests/test_s3_advanced.py::TestS3Configurations::test_custom_endpoint 
[gw2] [ 24%] FAILED tests/test_integration.py::TestDropboxIntegration::test_dropbox_setup 
tests/test_integration.py::TestDropboxIntegration::test_dropbox_upload_small_file 
[gw4] [ 24%] FAILED tests/test_s3_advanced.py::TestS3Configurations::test_custom_endpoint 
tests/test_s3_advanced.py::TestS3Configurations::test_path_style_endpoint 
[gw4] [ 25%] FAILED tests/test_s3_advanced.py::TestS3Configurations::test_path_style_endpoint 
tests/test_s3_advanced.py::TestS3Configurations::test_custom_region_endpoint 
[gw4] [ 26%] FAILED tests/test_s3_advanced.py::TestS3Configurations::test_custom_region_endpoint 
tests/test_s3_advanced.py::TestS3MultipartUploads::test_multipart_upload 
[gw4] [ 26%] FAILED tests/test_s3_advanced.py::TestS3MultipartUploads::test_multipart_upload 
tests/test_s3_advanced.py::TestS3MultipartUploads::test_multipart_upload_failure 
[gw2] [ 27%] FAILED tests/test_integration.py::TestDropboxIntegration::test_dropbox_upload_small_file 
tests/test_integration.py::TestDropboxIntegration::test_dropbox_upload_large_file 
[gw4] [ 28%] FAILED tests/test_s3_advanced.py::TestS3MultipartUploads::test_multipart_upload_failure 
tests/test_twat_fs.py::ruff 
[gw4] [ 28%] PASSED tests/test_twat_fs.py::ruff 
tests/test_twat_fs.py::ruff::format 
[gw4] [ 29%] PASSED tests/test_twat_fs.py::ruff::format 
tests/test_twat_fs.py::black 
[gw2] [ 30%] FAILED tests/test_integration.py::TestDropboxIntegration::test_dropbox_upload_large_file 
tests/test_twat_fs.py::test_version 
[gw2] [ 30%] PASSED tests/test_twat_fs.py::test_version 
tests/test_upload.py::ruff 
[gw0] [ 31%] PASSED tests/__init__.py::black 
tests/test_async_utils.py::ruff 
[gw6] [ 32%] PASSED tests/test_filebin_pixeldrain.py::black 
tests/test_filebin_pixeldrain.py::test_filebin_upload_success 
[gw0] [ 32%] PASSED tests/test_async_utils.py::ruff 
[gw1] [ 33%] PASSED tests/test_async_utils.py::black 
tests/test_integration.py::TestFalIntegration::test_fal_setup 
[gw6] [ 34%] PASSED tests/test_filebin_pixeldrain.py::test_filebin_upload_success 
tests/test_async_utils.py::TestRunAsync::test_run_async_with_successful_coroutine 
tests/test_filebin_pixeldrain.py::test_filebin_upload_failure 
[gw1] [ 34%] PASSED tests/test_async_utils.py::TestRunAsync::test_run_async_with_successful_coroutine 
tests/test_async_utils.py::TestRunAsync::test_run_async_with_exception 
[gw1] [ 35%] PASSED tests/test_async_utils.py::TestRunAsync::test_run_async_with_exception 
tests/test_upload.py::TestProviderSetup::test_setup_provider_success 
[gw2] [ 36%] FAILED tests/test_upload.py::ruff 
tests/test_upload.py::ruff::format 
[gw2] [ 36%] PASSED tests/test_upload.py::ruff::format 
tests/test_upload.py::black 
[gw3] [ 37%] PASSED tests/test_integration.py::black 
tests/test_integration.py::TestS3Integration::test_s3_setup 
[gw3] [ 38%] SKIPPED tests/test_integration.py::TestS3Integration::test_s3_setup 
tests/test_integration.py::TestS3Integration::test_s3_upload_small_file 
[gw3] [ 38%] SKIPPED tests/test_integration.py::TestS3Integration::test_s3_upload_small_file 
tests/test_upload.py::TestProviderAuth::test_dropbox_auth_with_token 
[gw3] [ 39%] PASSED tests/test_upload.py::TestProviderAuth::test_dropbox_auth_with_token 
tests/test_upload.py::TestProviderAuth::test_dropbox_auth_without_token 
[gw3] [ 40%] PASSED tests/test_upload.py::TestProviderAuth::test_dropbox_auth_without_token 
tests/test_upload.py::TestProviderAuth::test_s3_auth_with_credentials 
[gw0] [ 40%] FAILED tests/test_integration.py::TestFalIntegration::test_fal_setup 
tests/test_integration.py::TestFalIntegration::test_fal_upload_small_file 
[gw0] [ 41%] FAILED tests/test_integration.py::TestFalIntegration::test_fal_upload_small_file 
tests/test_integration.py::TestFalIntegration::test_fal_upload_large_file 
[gw0] [ 42%] FAILED tests/test_integration.py::TestFalIntegration::test_fal_upload_large_file 
[gw1] [ 42%] FAILED tests/test_upload.py::TestProviderSetup::test_setup_provider_success 
tests/test_integration.py::TestSetupIntegration::test_setup_all_providers 
tests/test_upload.py::TestProviderSetup::test_setup_provider_failure 
[gw1] [ 43%] FAILED tests/test_upload.py::TestProviderSetup::test_setup_provider_failure 
tests/test_upload.py::TestProviderSetup::test_setup_provider_dropbox 
[gw3] [ 44%] FAILED tests/test_upload.py::TestProviderAuth::test_s3_auth_with_credentials 
tests/test_upload.py::TestProviderAuth::test_s3_auth_without_credentials 
[gw3] [ 44%] PASSED tests/test_upload.py::TestProviderAuth::test_s3_auth_without_credentials 
tests/test_upload.py::TestProviderAuth::test_s3_auth_with_invalid_credentials 
[gw3] [ 45%] FAILED tests/test_upload.py::TestProviderAuth::test_s3_auth_with_invalid_credentials 
tests/test_upload.py::TestUploadFile::test_upload_fallback_on_upload_failure 
[gw5] [ 46%] PASSED tests/test_s3_advanced.py::black 
tests/test_s3_advanced.py::TestAwsCredentialProviders::test_environment_credentials 
[gw5] [ 46%] FAILED tests/test_s3_advanced.py::TestAwsCredentialProviders::test_environment_credentials 
tests/test_s3_advanced.py::TestAwsCredentialProviders::test_shared_credentials_file 
[gw5] [ 47%] FAILED tests/test_s3_advanced.py::TestAwsCredentialProviders::test_shared_credentials_file 
tests/test_s3_advanced.py::TestAwsCredentialProviders::test_assume_role 
[gw5] [ 48%] FAILED tests/test_s3_advanced.py::TestAwsCredentialProviders::test_assume_role 
tests/test_upload.py::TestUploadFile::test_invalid_provider 
[gw5] [ 48%] PASSED tests/test_upload.py::TestUploadFile::test_invalid_provider 
tests/test_upload.py::TestUploadFile::test_upload_with_s3_provider 
[gw5] [ 49%] FAILED tests/test_upload.py::TestUploadFile::test_upload_with_s3_provider 
[gw3] [ 50%] ERROR tests/test_upload.py::TestUploadFile::test_upload_fallback_on_upload_failure 
tests/test_upload.py::TestUploadFile::test_s3_upload_failure 
tests/test_upload.py::TestUploadFile::test_all_providers_fail 
[gw5] [ 50%] FAILED tests/test_upload.py::TestUploadFile::test_s3_upload_failure 
[gw0] [ 51%] FAILED tests/test_integration.py::TestSetupIntegration::test_setup_all_providers 
tests/test_upload.py::TestEdgeCases::test_empty_file 
tests/test_upload.py::TestUploadFile::test_upload_with_default_provider 
[gw1] [ 52%] FAILED tests/test_upload.py::TestProviderSetup::test_setup_provider_dropbox 
tests/test_upload.py::TestUploadFile::test_upload_with_provider_list 
[gw1] [ 52%] FAILED tests/test_upload.py::TestUploadFile::test_upload_with_provider_list 
tests/test_upload.py::TestUploadFile::test_upload_fallback_on_auth_failure 
[gw1] [ 53%] ERROR tests/test_upload.py::TestUploadFile::test_upload_fallback_on_auth_failure 
tests/test_upload.py::TestEdgeCases::test_directory_upload 
[gw1] [ 54%] PASSED tests/test_upload.py::TestEdgeCases::test_directory_upload 
tests/test_upload.py::TestEdgeCases::test_no_read_permission 
[gw1] [ 54%] FAILED tests/test_upload.py::TestEdgeCases::test_no_read_permission 
tests/test_upload.py::TestEdgeCases::test_different_file_sizes[1] 
[gw5] [ 55%] FAILED tests/test_upload.py::TestEdgeCases::test_empty_file 
tests/test_upload.py::TestEdgeCases::test_very_long_filename 
[gw7] [ 56%] PASSED tests/test_filebin_pixeldrain.py::test_pixeldrain_upload_failure 
tests/test_filebin_pixeldrain.py::test_filebin_provider_initialization 
[gw7] [ 56%] PASSED tests/test_filebin_pixeldrain.py::test_filebin_provider_initialization 
tests/test_filebin_pixeldrain.py::test_pixeldrain_provider_initialization 
[gw7] [ 57%] PASSED tests/test_filebin_pixeldrain.py::test_pixeldrain_provider_initialization 
[gw5] [ 58%] FAILED tests/test_upload.py::TestEdgeCases::test_very_long_filename 
tests/test_upload.py::TestEdgeCases::test_different_file_sizes[10] 
tests/test_upload.py::TestEdgeCases::test_nonexistent_file 
[gw5] [ 58%] PASSED tests/test_upload.py::TestEdgeCases::test_nonexistent_file 
[gw0] [ 59%] FAILED tests/test_upload.py::TestUploadFile::test_upload_with_default_provider 
tests/test_upload.py::TestCatboxProvider::test_catbox_auth_without_userhash 
tests/test_upload.py::TestUploadFile::test_upload_with_specific_provider 
[gw3] [ 60%] FAILED tests/test_upload.py::TestUploadFile::test_all_providers_fail 
tests/test_upload.py::TestEdgeCases::test_special_characters_in_filename 
[gw5] [ 60%] FAILED tests/test_upload.py::TestCatboxProvider::test_catbox_auth_without_userhash 
[gw4] [ 61%] FAILED tests/test_twat_fs.py::black 
[gw0] [ 62%] FAILED tests/test_upload.py::TestUploadFile::test_upload_with_specific_provider 
tests/test_upload.py::TestCatboxProvider::test_catbox_upload_file 
tests/test_upload.py::TestProviderSetup::test_setup_working_provider 
tests/test_upload.py::TestCatboxProvider::test_catbox_upload_url 
[gw5] [ 62%] FAILED tests/test_upload.py::TestCatboxProvider::test_catbox_upload_file 
[gw0] [ 63%] FAILED tests/test_upload.py::TestCatboxProvider::test_catbox_upload_url 
[gw4] [ 64%] FAILED tests/test_upload.py::TestProviderSetup::test_setup_working_provider 
tests/test_upload.py::TestLitterboxProvider::test_litterbox_default_expiration 
[gw5] [ 64%] PASSED tests/test_upload.py::TestLitterboxProvider::test_litterbox_default_expiration 
tests/test_upload.py::TestLitterboxProvider::test_litterbox_custom_expiration 
[gw0] [ 65%] PASSED tests/test_upload.py::TestLitterboxProvider::test_litterbox_custom_expiration 
tests/test_upload.py::TestProviderSetup::test_setup_missing_credentials 
tests/test_upload.py::TestLitterboxProvider::test_litterbox_invalid_expiration 
[gw5] [ 66%] PASSED tests/test_upload.py::TestLitterboxProvider::test_litterbox_invalid_expiration 
tests/test_upload.py::TestLitterboxProvider::test_litterbox_upload_file 
tests/test_upload.py::test_circular_fallback 
[gw4] [ 66%] FAILED tests/test_upload.py::TestProviderSetup::test_setup_missing_credentials 
tests/test_upload.py::TestProviderSetup::test_setup_missing_dependencies 
[gw0] [ 67%] FAILED tests/test_upload.py::TestLitterboxProvider::test_litterbox_upload_file 
tests/test_upload.py::test_fragile_mode 
[gw4] [ 68%] FAILED tests/test_upload.py::TestProviderSetup::test_setup_missing_dependencies 
tests/test_utils.py::ruff 
[gw0] [ 68%] FAILED tests/test_upload.py::test_fragile_mode 
tests/test_utils.py::ruff::format 
[gw0] [ 69%] PASSED tests/test_utils.py::ruff::format 
tests/test_utils.py::TestCreateProviderHelp::test_create_provider_help 
[gw0] [ 70%] PASSED tests/test_utils.py::TestCreateProviderHelp::test_create_provider_help 
tests/test_utils.py::TestSafeFileHandle::test_safe_file_handle_with_valid_file 
[gw0] [ 70%] PASSED tests/test_utils.py::TestSafeFileHandle::test_safe_file_handle_with_valid_file 
tests/test_utils.py::TestSafeFileHandle::test_safe_file_handle_with_nonexistent_file 
[gw0] [ 71%] PASSED tests/test_utils.py::TestSafeFileHandle::test_safe_file_handle_with_nonexistent_file 
tests/test_utils.py::TestSafeFileHandle::test_safe_file_handle_with_directory 
[gw0] [ 72%] PASSED tests/test_utils.py::TestSafeFileHandle::test_safe_file_handle_with_directory 
tests/test_utils.py::TestValidateFile::test_validate_file_with_valid_file 
[gw0] [ 72%] PASSED tests/test_utils.py::TestValidateFile::test_validate_file_with_valid_file 
tests/test_utils.py::TestValidateFile::test_validate_file_with_nonexistent_file 
[gw0] [ 73%] PASSED tests/test_utils.py::TestValidateFile::test_validate_file_with_nonexistent_file 
[gw5] [ 74%] ERROR tests/test_upload.py::test_circular_fallback 
[gw1] [ 74%] FAILED tests/test_upload.py::TestEdgeCases::test_different_file_sizes[1] 
tests/test_utils.py::TestValidateFile::test_validate_file_with_directory 
[gw0] [ 75%] PASSED tests/test_utils.py::TestValidateFile::test_validate_file_with_directory 
tests/test_upload.py::test_custom_provider_list_circular_fallback 
tests/test_upload.py::TestEdgeCases::test_different_file_sizes[5] 
tests/test_utils.py::TestValidateFile::test_validate_file_with_unreadable_file 
[gw0] [ 76%] PASSED tests/test_utils.py::TestValidateFile::test_validate_file_with_unreadable_file 
tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_429_requests 
[gw0] [ 76%] PASSED tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_429_requests 
tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_429_aiohttp 
[gw0] [ 77%] PASSED tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_429_aiohttp 
tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_503_requests 
[gw0] [ 78%] PASSED tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_503_requests 
tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_400_requests 
[gw0] [ 78%] PASSED tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_400_requests 
tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_other_error_requests 
[gw0] [ 79%] PASSED tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_other_error_requests 
tests/test_utils.py::TestGetEnvCredentials::test_get_env_credentials_with_all_required_vars 
[gw0] [ 80%] PASSED tests/test_utils.py::TestGetEnvCredentials::test_get_env_credentials_with_all_required_vars 
tests/test_utils.py::TestGetEnvCredentials::test_get_env_credentials_with_missing_required_vars 
[gw0] [ 80%] PASSED tests/test_utils.py::TestGetEnvCredentials::test_get_env_credentials_with_missing_required_vars 
tests/test_utils.py::TestGetEnvCredentials::test_get_env_credentials_with_optional_vars 
[gw0] [ 81%] PASSED tests/test_utils.py::TestGetEnvCredentials::test_get_env_credentials_with_optional_vars 
tests/test_utils.py::TestGetEnvCredentials::test_get_env_credentials_with_missing_optional_vars 
[gw0] [ 82%] PASSED tests/test_utils.py::TestGetEnvCredentials::test_get_env_credentials_with_missing_optional_vars 
tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_get_provider 
[gw0] [ 82%] PASSED tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_get_provider 
tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_direct_instantiation 
[gw0] [ 83%] PASSED tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_direct_instantiation 
tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_credentials 
[gw0] [ 84%] PASSED tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_credentials 
tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_no_credentials 
[gw0] [ 84%] PASSED tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_no_credentials 
[gw5] [ 85%] ERROR tests/test_upload.py::test_custom_provider_list_circular_fallback 
[gw4] [ 86%] FAILED tests/test_utils.py::ruff 
tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_error 
tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_200_requests 
tests/test_utils.py::black 
[gw0] [ 86%] PASSED tests/test_utils.py::TestCreateProviderInstance::test_create_provider_instance_with_error 
[gw5] [ 87%] PASSED tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_200_requests 
tests/test_utils.py::TestStandardUploadWrapper::test_standard_upload_wrapper_with_valid_provider 
tests/test_utils.py::TestLogUploadAttempt::test_log_upload_attempt_success 
[gw0] [ 88%] PASSED tests/test_utils.py::TestStandardUploadWrapper::test_standard_upload_wrapper_with_valid_provider 
[gw5] [ 88%] PASSED tests/test_utils.py::TestLogUploadAttempt::test_log_upload_attempt_success 
tests/test_utils.py::TestLogUploadAttempt::test_log_upload_attempt_failure 
[gw0] [ 89%] PASSED tests/test_utils.py::TestLogUploadAttempt::test_log_upload_attempt_failure 
[gw3] [ 90%] FAILED tests/test_upload.py::TestEdgeCases::test_special_characters_in_filename 
[gw2] [ 90%] PASSED tests/test_upload.py::black 
tests/test_upload.py::TestProviderSetup::test_setup_all_providers_check 
tests/test_upload.py::TestEdgeCases::test_unicode_filename 
[gw1] [ 91%] FAILED tests/test_upload.py::TestEdgeCases::test_different_file_sizes[5] 
tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_200_aiohttp 
[gw1] [ 92%] PASSED tests/test_utils.py::TestHandleHttpResponse::test_handle_http_response_with_200_aiohttp 
[gw7] [ 92%] FAILED tests/test_upload.py::TestEdgeCases::test_different_file_sizes[10] 
tests/test_upload.py::TestCatboxProvider::test_catbox_auth_with_userhash 
[gw7] [ 93%] FAILED tests/test_upload.py::TestCatboxProvider::test_catbox_auth_with_userhash 
[gw2] [ 94%] FAILED tests/test_upload.py::TestProviderSetup::test_setup_all_providers_check 
tests/test_upload.py::TestProviderAuth::test_fal_auth_with_key 
[gw2] [ 94%] PASSED tests/test_upload.py::TestProviderAuth::test_fal_auth_with_key 
tests/test_upload.py::TestProviderAuth::test_fal_auth_without_key 
[gw2] [ 95%] PASSED tests/test_upload.py::TestProviderAuth::test_fal_auth_without_key 
[gw3] [ 96%] FAILED tests/test_upload.py::TestEdgeCases::test_unicode_filename 
[gw6] [ 96%] PASSED tests/test_filebin_pixeldrain.py::test_filebin_upload_failure 
tests/test_upload.py::TestProviderSetup::test_setup_invalid_provider 
[gw6] [ 97%] FAILED tests/test_upload.py::TestProviderSetup::test_setup_invalid_provider 
tests/test_upload.py::TestProviderSetup::test_setup_all_providers 
[gw6] [ 98%] ERROR tests/test_upload.py::TestProviderSetup::test_setup_all_providers 
tests/test_upload.py::TestProviderSetup::test_setup_all_providers_with_failures 
[gw4] [ 98%] PASSED tests/test_utils.py::black 
tests/test_utils.py::TestStandardUploadWrapper::test_standard_upload_wrapper_with_none_provider 
[gw4] [ 99%] PASSED tests/test_utils.py::TestStandardUploadWrapper::test_standard_upload_wrapper_with_none_provider 
[gw6] [100%] FAILED tests/test_upload.py::TestProviderSetup::test_setup_all_providers_with_failures 

==================================== ERRORS ====================================
_ ERROR at setup of TestLitterboxIntegration.test_litterbox_upload_small_file __
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python
file /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py, line 227
      def test_litterbox_upload_small_file(self, small_file):
E       fixture 'small_file' not found
>       available fixtures: _class_backend_context, _session_event_loop, _syrupy_apply_ide_patches, allowed_hosts, anyio_backend, anyio_backend_name, anyio_backend_options, backend_context, benchmark, benchmark_weave, block_network, branched_repo, cache, capfd, capfdbinary, capfire, caplog, capsys, capsysbinary, class_mocker, cleanup_test_files, cov, dash_br, dash_duo, dash_duo_mp, dash_multi_process_server, dash_process_server, dash_thread_server, dashjl, dashjl_server, dashr, dashr_server, dask_session, db_uri, default_cassette_name, disable_recording, diskcache_manager, docker_cleanup, docker_compose_command, docker_compose_file, docker_compose_project_name, docker_ip, docker_services, docker_setup, doctest_namespace, duckdask_session, duckdb_session, event_loop, event_loop_policy, find_project_root_cache_clear, git_repo, hg_repo, init_config, large_test_file, mocker, module_mocker, mongodb_instance, mongodb_uri, monkeypatch, native_session, no_cover, package_mocker, pandas_session, pytestconfig, ray_session, record_mode, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, session_mocker, snapshot, socket_disabled, socket_enabled, spark_session, sparkconnect_session, subtests, temp_work_dir, testrun_uid, tests/test_integration.py::<event_loop>, tests/test_integration.py::TestLitterboxIntegration::<event_loop>, time_machine, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, vcr, vcr_cassette_dir, vcr_config, vcr_markers, virtualenv, worker_id, workspace
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py:227
_ ERROR at setup of TestLitterboxIntegration.test_litterbox_upload_large_file __
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python
file /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py, line 234
      def test_litterbox_upload_large_file(self, large_file):
E       fixture 'large_file' not found
>       available fixtures: _class_backend_context, _session_event_loop, _syrupy_apply_ide_patches, allowed_hosts, anyio_backend, anyio_backend_name, anyio_backend_options, backend_context, benchmark, benchmark_weave, block_network, branched_repo, cache, capfd, capfdbinary, capfire, caplog, capsys, capsysbinary, class_mocker, cleanup_test_files, cov, dash_br, dash_duo, dash_duo_mp, dash_multi_process_server, dash_process_server, dash_thread_server, dashjl, dashjl_server, dashr, dashr_server, dask_session, db_uri, default_cassette_name, disable_recording, diskcache_manager, docker_cleanup, docker_compose_command, docker_compose_file, docker_compose_project_name, docker_ip, docker_services, docker_setup, doctest_namespace, duckdask_session, duckdb_session, event_loop, event_loop_policy, find_project_root_cache_clear, git_repo, hg_repo, init_config, large_test_file, mocker, module_mocker, mongodb_instance, mongodb_uri, monkeypatch, native_session, no_cover, package_mocker, pandas_session, pytestconfig, ray_session, record_mode, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, session_mocker, snapshot, socket_disabled, socket_enabled, spark_session, sparkconnect_session, subtests, temp_work_dir, testrun_uid, tests/test_integration.py::<event_loop>, tests/test_integration.py::TestLitterboxIntegration::<event_loop>, time_machine, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, vcr, vcr_cassette_dir, vcr_config, vcr_markers, virtualenv, worker_id, workspace
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py:234
_ ERROR at setup of TestLitterboxIntegration.test_litterbox_different_expirations _
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python
file /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py, line 243
      def test_litterbox_different_expirations(self, small_file):
E       fixture 'small_file' not found
>       available fixtures: _class_backend_context, _session_event_loop, _syrupy_apply_ide_patches, allowed_hosts, anyio_backend, anyio_backend_name, anyio_backend_options, backend_context, benchmark, benchmark_weave, block_network, branched_repo, cache, capfd, capfdbinary, capfire, caplog, capsys, capsysbinary, class_mocker, cleanup_test_files, cov, dash_br, dash_duo, dash_duo_mp, dash_multi_process_server, dash_process_server, dash_thread_server, dashjl, dashjl_server, dashr, dashr_server, dask_session, db_uri, default_cassette_name, disable_recording, diskcache_manager, docker_cleanup, docker_compose_command, docker_compose_file, docker_compose_project_name, docker_ip, docker_services, docker_setup, doctest_namespace, duckdask_session, duckdb_session, event_loop, event_loop_policy, find_project_root_cache_clear, git_repo, hg_repo, init_config, large_test_file, mocker, module_mocker, mongodb_instance, mongodb_uri, monkeypatch, native_session, no_cover, package_mocker, pandas_session, pytestconfig, ray_session, record_mode, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, session_mocker, snapshot, socket_disabled, socket_enabled, spark_session, sparkconnect_session, subtests, temp_work_dir, testrun_uid, tests/test_integration.py::<event_loop>, tests/test_integration.py::TestLitterboxIntegration::<event_loop>, time_machine, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, vcr, vcr_cassette_dir, vcr_config, vcr_markers, virtualenv, worker_id, workspace
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py:243
____ ERROR at setup of TestCatboxIntegration.test_catbox_upload_small_file _____
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python
file /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py, line 189
      def test_catbox_upload_small_file(self, small_file):
E       fixture 'small_file' not found
>       available fixtures: _class_backend_context, _session_event_loop, _syrupy_apply_ide_patches, allowed_hosts, anyio_backend, anyio_backend_name, anyio_backend_options, backend_context, benchmark, benchmark_weave, block_network, branched_repo, cache, capfd, capfdbinary, capfire, caplog, capsys, capsysbinary, class_mocker, cleanup_test_files, cov, dash_br, dash_duo, dash_duo_mp, dash_multi_process_server, dash_process_server, dash_thread_server, dashjl, dashjl_server, dashr, dashr_server, dask_session, db_uri, default_cassette_name, disable_recording, diskcache_manager, docker_cleanup, docker_compose_command, docker_compose_file, docker_compose_project_name, docker_ip, docker_services, docker_setup, doctest_namespace, duckdask_session, duckdb_session, event_loop, event_loop_policy, find_project_root_cache_clear, git_repo, hg_repo, init_config, large_test_file, mocker, module_mocker, mongodb_instance, mongodb_uri, monkeypatch, native_session, no_cover, package_mocker, pandas_session, pytestconfig, ray_session, record_mode, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, session_mocker, snapshot, socket_disabled, socket_enabled, spark_session, sparkconnect_session, subtests, temp_work_dir, testrun_uid, tests/test_integration.py::<event_loop>, tests/test_integration.py::TestCatboxIntegration::<event_loop>, time_machine, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, vcr, vcr_cassette_dir, vcr_config, vcr_markers, virtualenv, worker_id, workspace
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py:189
____ ERROR at setup of TestCatboxIntegration.test_catbox_upload_large_file _____
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python
file /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py, line 195
      def test_catbox_upload_large_file(self, large_file):
E       fixture 'large_file' not found
>       available fixtures: _class_backend_context, _session_event_loop, _syrupy_apply_ide_patches, allowed_hosts, anyio_backend, anyio_backend_name, anyio_backend_options, backend_context, benchmark, benchmark_weave, block_network, branched_repo, cache, capfd, capfdbinary, capfire, caplog, capsys, capsysbinary, class_mocker, cleanup_test_files, cov, dash_br, dash_duo, dash_duo_mp, dash_multi_process_server, dash_process_server, dash_thread_server, dashjl, dashjl_server, dashr, dashr_server, dask_session, db_uri, default_cassette_name, disable_recording, diskcache_manager, docker_cleanup, docker_compose_command, docker_compose_file, docker_compose_project_name, docker_ip, docker_services, docker_setup, doctest_namespace, duckdask_session, duckdb_session, event_loop, event_loop_policy, find_project_root_cache_clear, git_repo, hg_repo, init_config, large_test_file, mocker, module_mocker, mongodb_instance, mongodb_uri, monkeypatch, native_session, no_cover, package_mocker, pandas_session, pytestconfig, ray_session, record_mode, record_property, record_testsuite_property, record_xml_attribute, recwarn, requests_mock, session_mocker, snapshot, socket_disabled, socket_enabled, spark_session, sparkconnect_session, subtests, temp_work_dir, testrun_uid, tests/test_integration.py::<event_loop>, tests/test_integration.py::TestCatboxIntegration::<event_loop>, time_machine, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, vcr, vcr_cassette_dir, vcr_config, vcr_markers, virtualenv, worker_id, workspace
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_integration.py:195
___ ERROR at setup of TestUploadFile.test_upload_fallback_on_upload_failure ____
[gw3] darwin -- Python 3.12.8 /usr/local/bin/python

    @pytest.fixture
    def mock_dropbox_provider() -> Generator[MagicMock, None, None]:
        """Mock Dropbox provider."""
>       with patch("twat_fs.upload_providers.dropbox.DropboxProvider") as mock:

tests/test_upload.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1467: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x11aac9100>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'twat_fs.upload_providers.dropbox' from '/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/src/twat_fs/upload_providers/dropbox.py'> does not have the attribute 'DropboxProvider'

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1437: AttributeError
____ ERROR at setup of TestUploadFile.test_upload_fallback_on_auth_failure _____
[gw1] darwin -- Python 3.12.8 /usr/local/bin/python

    @pytest.fixture
    def mock_dropbox_provider() -> Generator[MagicMock, None, None]:
        """Mock Dropbox provider."""
>       with patch("twat_fs.upload_providers.dropbox.DropboxProvider") as mock:

tests/test_upload.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1467: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x11ad68470>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'twat_fs.upload_providers.dropbox' from '/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/src/twat_fs/upload_providers/dropbox.py'> does not have the attribute 'DropboxProvider'

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1437: AttributeError
___________________ ERROR at setup of test_circular_fallback ___________________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

    @pytest.fixture
    def mock_dropbox_provider() -> Generator[MagicMock, None, None]:
        """Mock Dropbox provider."""
>       with patch("twat_fs.upload_providers.dropbox.DropboxProvider") as mock:

tests/test_upload.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1467: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x123958bc0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'twat_fs.upload_providers.dropbox' from '/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/src/twat_fs/upload_providers/dropbox.py'> does not have the attribute 'DropboxProvider'

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1437: AttributeError
________ ERROR at setup of test_custom_provider_list_circular_fallback _________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

    @pytest.fixture
    def mock_dropbox_provider() -> Generator[MagicMock, None, None]:
        """Mock Dropbox provider."""
>       with patch("twat_fs.upload_providers.dropbox.DropboxProvider") as mock:

tests/test_upload.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1467: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x12395abd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'twat_fs.upload_providers.dropbox' from '/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/src/twat_fs/upload_providers/dropbox.py'> does not have the attribute 'DropboxProvider'

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1437: AttributeError
_________ ERROR at setup of TestProviderSetup.test_setup_all_providers _________
[gw6] darwin -- Python 3.12.8 /usr/local/bin/python

    @pytest.fixture
    def mock_dropbox_provider() -> Generator[MagicMock, None, None]:
        """Mock Dropbox provider."""
>       with patch("twat_fs.upload_providers.dropbox.DropboxProvider") as mock:

tests/test_upload.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1467: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x11fc95be0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'twat_fs.upload_providers.dropbox' from '/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/src/twat_fs/upload_providers/dropbox.py'> does not have the attribute 'DropboxProvider'

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1437: AttributeError
=================================== FAILURES ===================================
___________________ TestCatboxIntegration.test_catbox_setup ____________________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_integration.TestCatboxIntegration object at 0x122796d20>

    def test_catbox_setup(self):
        """Test Catbox provider setup."""
>       status, _ = setup_provider("catbox")
E       TypeError: cannot unpack non-iterable ProviderInfo object

tests/test_integration.py:184: TypeError
________________ TestLitterboxIntegration.test_litterbox_setup _________________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_integration.TestLitterboxIntegration object at 0x122797c50>

    def test_litterbox_setup(self):
        """Test Litterbox provider setup."""
>       status, _ = setup_provider("litterbox")
E       TypeError: cannot unpack non-iterable ProviderInfo object

tests/test_integration.py:224: TypeError
_________________________________ test session _________________________________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x11e789940>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>, kwargs = {'item': <RuffItem ruff>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_hooks.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x109bbc7d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x11e74feb0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_result.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_call() -> Generator[None]:
>       yield from thread_exception_runtest_hook()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/threadexception.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def thread_exception_runtest_hook() -> Generator[None]:
        with catch_threading_exception() as cm:
            try:
>               yield

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/threadexception.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_call() -> Generator[None]:
>       yield from unraisable_exception_runtest_hook()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/unraisableexception.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def unraisable_exception_runtest_hook() -> Generator[None]:
        with catch_unraisable_exception() as cm:
            try:
>               yield

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/unraisableexception.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.logging.LoggingPlugin object at 0x11c13b620>
item = <RuffItem ruff>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
>       yield from self._runtest_for(item, "call")

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/logging.py:846: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.logging.LoggingPlugin object at 0x11c13b620>
item = <RuffItem ruff>, when = 'call'

    def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None]:
        """Implement the internals of the pytest_runtest_xxx() hooks."""
        with catching_logs(
            self.caplog_handler,
            level=self.log_level,
        ) as caplog_handler, catching_logs(
            self.report_handler,
            level=self.log_level,
        ) as report_handler:
            caplog_handler.reset()
            report_handler.reset()
            item.stash[caplog_records_key][when] = caplog_handler.records
            item.stash[caplog_handler_key] = caplog_handler
    
            try:
>               yield

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/logging.py:829: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <RuffItem ruff>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/capture.py:880: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <RuffItem ruff>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/skipping.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <RuffItem ruff>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/runner.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <RuffItem ruff>

    def runtest(self):
>       self.handler(path=self.fspath)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pytest_ruff/__init__.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <RuffItem ruff>
path = local('/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_s3_advanced.py')

    def handler(self, path):
>       return check_file(path)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pytest_ruff/__init__.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_s3_advanced.py')

    def check_file(path):
        ruff = find_ruff_bin()
        command = [
            ruff,
            "check",
            path,
            "--quiet",
            "--output-format=full",
            "--force-exclude",
        ]
        child = Popen(command, stdout=PIPE, stderr=PIPE)
        stdout, stderr = child.communicate()
    
        if child.returncode == 1:
>           raise RuffError(stdout.decode())
E           pytest_ruff.RuffError: tests/test_s3_advanced.py:21:19: S105 Possible hardcoded password assigned to: "TEST_SECRET_KEY"
E              |
E           19 | TEST_BUCKET = "test-bucket"
E           20 | TEST_ACCESS_KEY = "test_key"
E           21 | TEST_SECRET_KEY = "test_secret"
E              |                   ^^^^^^^^^^^^^ S105
E           22 |
E           23 | # Test data
E              |

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pytest_ruff/__init__.py:101: RuffError
__________________ TestDropboxIntegration.test_dropbox_setup ___________________
[gw2] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_integration.TestDropboxIntegration object at 0x11c0f10d0>

    def test_dropbox_setup(self) -> None:
        """Test Dropbox setup."""
        result = setup_provider("dropbox")
        # Test should pass if either:
        # 1. Provider is properly configured (success is True)
        # 2. Provider needs setup (success is False and explanation contains setup instructions)
>       assert result.success is True or (
            result.success is False
            and "DROPBOX_ACCESS_TOKEN" in result.explanation
            and "setup" in result.explanation.lower()
        )
E       assert (False is True or (False is False and 'DROPBOX_ACCESS_TOKEN' in "Provider 'dropbox' needs configuration."))
E        +  where False = ProviderInfo(success=False, explanation="Provider 'dropbox' needs configuration.", help_info={'setup': "To use Dropbox storage:\n1. Create a Dropbox account if you don't have one\n2. Go to https://www.dropbox.com/developers/apps\n3. Create a new app or use an existing one\n4. Generate an access token from the app console\n5. Set the following environment variables:\n   - DROPBOX_ACCESS_TOKEN: Your Dropbox access token\n   Optional:\n   - DROPBOX_REFRESH_TOKEN: OAuth2 refresh token\n   - DROPBOX_APP_KEY: Dropbox app key\n   - DROPBOX_APP_SECRET: Dropbox app secret"}, timing=None).success
E        +  and   False = ProviderInfo(success=False, explanation="Provider 'dropbox' needs configuration.", help_info={'setup': "To use Dropbox storage:\n1. Create a Dropbox account if you don't have one\n2. Go to https://www.dropbox.com/developers/apps\n3. Create a new app or use an existing one\n4. Generate an access token from the app console\n5. Set the following environment variables:\n   - DROPBOX_ACCESS_TOKEN: Your Dropbox access token\n   Optional:\n   - DROPBOX_REFRESH_TOKEN: OAuth2 refresh token\n   - DROPBOX_APP_KEY: Dropbox app key\n   - DROPBOX_APP_SECRET: Dropbox app secret"}, timing=None).success
E        +  and   "Provider 'dropbox' needs configuration." = ProviderInfo(success=False, explanation="Provider 'dropbox' needs configuration.", help_info={'setup': "To use Dropbox storage:\n1. Create a Dropbox account if you don't have one\n2. Go to https://www.dropbox.com/developers/apps\n3. Create a new app or use an existing one\n4. Generate an access token from the app console\n5. Set the following environment variables:\n   - DROPBOX_ACCESS_TOKEN: Your Dropbox access token\n   Optional:\n   - DROPBOX_REFRESH_TOKEN: OAuth2 refresh token\n   - DROPBOX_APP_KEY: Dropbox app key\n   - DROPBOX_APP_SECRET: Dropbox app secret"}, timing=None).explanation

tests/test_integration.py:102: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Failed to get account info: AuthError('3a311d885fcb4e199aa78bc20b1301f6', AuthError('expired_access_token', None))
Error: Dropbox token has expired and cannot be refreshed automatically.
To enable automatic token refresh:
1. Set DROPBOX_REFRESH_TOKEN environment variable
2. Set DROPBOX_APP_KEY environment variable
For now, please generate a new access token.
------------------------------ Captured log call -------------------------------
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
INFO     dropbox:dropbox_client.py:488 ExpiredCredentials status_code=401: Refreshing and Retrying
WARNING  dropbox:dropbox_client.py:386 Unable to refresh access token without                 refresh token and app key
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
__________________ TestS3Configurations.test_custom_endpoint ___________________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_s3_advanced.TestS3Configurations object at 0x11d844b60>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x11e79c470>

>   ???
E   KeyError: 'endpoint_url'

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/twat_fs/tests/test_s3_advanced.py:110: KeyError
________________ TestS3Configurations.test_path_style_endpoint _________________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_s3_advanced.TestS3Configurations object at 0x11d8447a0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x11e79d4c0>

>   ???
E   KeyError: 'path_style'

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/twat_fs/tests/test_s3_advanced.py:129: KeyError
_______________ TestS3Configurations.test_custom_region_endpoint _______________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_s3_advanced.TestS3Configurations object at 0x11d846030>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x11e79ecf0>

>   ???
E   TypeError: get_provider() takes 0 positional arguments but 1 was given

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/twat_fs/tests/test_s3_advanced.py:157: TypeError
_________________ TestS3MultipartUploads.test_multipart_upload _________________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_s3_advanced.TestS3MultipartUploads object at 0x11d846a20>
large_file = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw4/test_multipart_upload0/large_test.bin')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x11e7facf0>

>   ???
E   AttributeError: 'UploadResult' object has no attribute 'startswith'

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/twat_fs/tests/test_s3_advanced.py:191: AttributeError
----------------------------- Captured stdout call -----------------------------
Successfully uploaded /private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw4/test_multipart_upload0/large_test.bin using s3
____________ TestDropboxIntegration.test_dropbox_upload_small_file _____________
[gw2] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_integration.TestDropboxIntegration object at 0x11c0f1460>

    def test_dropbox_upload_small_file(self) -> None:
        """Test uploading a small file to Dropbox."""
        try:
            url = upload_file(SMALL_FILE, provider="dropbox")
>           assert url.startswith("https://")
E           AssertionError: assert False
E            +  where False = <built-in method startswith of str object at 0x107f32538>('https://')
E            +    where <built-in method startswith of str object at 0x107f32538> = ''.startswith

tests/test_integration.py:112: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Failed to get account info: AuthError('d6c30829b453479bb940f0e7a6891a73', AuthError('expired_access_token', None))
Error: Dropbox token has expired and cannot be refreshed automatically.
To enable automatic token refresh:
1. Set DROPBOX_REFRESH_TOKEN environment variable
2. Set DROPBOX_APP_KEY environment variable
For now, please generate a new access token.
Error: Failed to initialize provider dropbox
------------------------------ Captured log call -------------------------------
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
INFO     dropbox:dropbox_client.py:488 ExpiredCredentials status_code=401: Refreshing and Retrying
WARNING  dropbox:dropbox_client.py:386 Unable to refresh access token without                 refresh token and app key
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
_____________ TestS3MultipartUploads.test_multipart_upload_failure _____________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

self = <twat_fs.upload_providers.s3.S3Provider object at 0x11e7e6ff0>
file = <_io.BufferedReader name='/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw4/test_multipart_upload_failure0/large_test.bin'>
key = 'large_test.bin'

    def _do_upload(self, file: BinaryIO, key: str) -> str:
        """
        Internal implementation of the file upload to S3.
    
        Args:
            file: Open file handle to upload
            key: S3 object key
    
        Returns:
            str: URL of the uploaded file
    
        Raises:
            RetryableError: If the upload fails due to temporary issues
            NonRetryableError: If the upload fails for any other reason
        """
        bucket = self.credentials["AWS_S3_BUCKET"]
    
        try:
            # Reset file pointer to beginning
            file.seek(0)
    
            # Upload the file
>           self.client.upload_fileobj(file, bucket, key)

src/twat_fs/upload_providers/s3.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1139: in __call__
    return self._mock_call(*args, **kwargs)
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1143: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.upload_fileobj' id='4806562144'>
args = (<_io.BufferedReader name='/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw4/test_multipart_upload_failure0/large_test.bin'>, 'test-bucket', 'large_test.bin')
kwargs = {}
effect = ClientError('An error occurred (InternalError) when calling the UploadFileObj operation: Internal error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               botocore.exceptions.ClientError: An error occurred (InternalError) when calling the UploadFileObj operation: Internal error

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1198: ClientError

The above exception was the direct cause of the following exception:

self = <tests.test_s3_advanced.TestS3MultipartUploads object at 0x11d846e10>
large_file = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw4/test_multipart_upload_failure0/large_test.bin')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x11e7ef2f0>

>   ???

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/twat_fs/tests/test_s3_advanced.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/twat_fs/upload_providers/s3.py:323: in upload_file
    return standard_upload_wrapper(
src/twat_fs/upload_providers/utils.py:245: in standard_upload_wrapper
    return provider.upload_file(local_path, remote_path, **kwargs)
src/twat_fs/upload_providers/simple.py:110: in upload_file
    result = self.upload_file_impl(file)
src/twat_fs/upload_providers/s3.py:200: in upload_file_impl
    url = self._do_upload(file, key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <twat_fs.upload_providers.s3.S3Provider object at 0x11e7e6ff0>
file = <_io.BufferedReader name='/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw4/test_multipart_upload_failure0/large_test.bin'>
key = 'large_test.bin'

    def _do_upload(self, file: BinaryIO, key: str) -> str:
        """
        Internal implementation of the file upload to S3.
    
        Args:
            file: Open file handle to upload
            key: S3 object key
    
        Returns:
            str: URL of the uploaded file
    
        Raises:
            RetryableError: If the upload fails due to temporary issues
            NonRetryableError: If the upload fails for any other reason
        """
        bucket = self.credentials["AWS_S3_BUCKET"]
    
        try:
            # Reset file pointer to beginning
            file.seek(0)
    
            # Upload the file
            self.client.upload_fileobj(file, bucket, key)
    
            # Return the URL
            return self._get_s3_url(key)
        except Exception as e:
            # Handle different types of errors
            error_str = str(e)
            if "ConnectionError" in error_str or "Timeout" in error_str:
                msg = f"Temporary connection issue: {e}"
                raise RetryableError(msg, self.provider_name) from e
            else:
                msg = f"Upload failed: {e}"
>               raise NonRetryableError(msg, self.provider_name) from e
E               twat_fs.upload_providers.core.NonRetryableError: Upload failed: An error occurred (InternalError) when calling the UploadFileObj operation: Internal error

src/twat_fs/upload_providers/s3.py:176: NonRetryableError
____________ TestDropboxIntegration.test_dropbox_upload_large_file _____________
[gw2] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_integration.TestDropboxIntegration object at 0x11c0f17f0>
large_test_file = PosixPath('/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/data/large_test.bin')

    def test_dropbox_upload_large_file(self, large_test_file: Path) -> None:
        """Test uploading a large file to Dropbox."""
        try:
            url = upload_file(large_test_file, provider="dropbox")
>           assert url.startswith("https://")
E           AssertionError: assert False
E            +  where False = <built-in method startswith of str object at 0x107f32538>('https://')
E            +    where <built-in method startswith of str object at 0x107f32538> = ''.startswith

tests/test_integration.py:122: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Failed to get account info: AuthError('462a8c2d870a427eb4bff28e81ab54c7', AuthError('expired_access_token', None))
Error: Dropbox token has expired and cannot be refreshed automatically.
To enable automatic token refresh:
1. Set DROPBOX_REFRESH_TOKEN environment variable
2. Set DROPBOX_APP_KEY environment variable
For now, please generate a new access token.
Error: Failed to initialize provider dropbox
------------------------------ Captured log call -------------------------------
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
INFO     dropbox:dropbox_client.py:488 ExpiredCredentials status_code=401: Refreshing and Retrying
WARNING  dropbox:dropbox_client.py:386 Unable to refresh access token without                 refresh token and app key
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
_________________________________ test session _________________________________
[gw2] darwin -- Python 3.12.8 /usr/local/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x11d0b67a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>, kwargs = {'item': <RuffItem ruff>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_hooks.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x107088b00>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x11d00db40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_result.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_call() -> Generator[None]:
>       yield from thread_exception_runtest_hook()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/threadexception.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def thread_exception_runtest_hook() -> Generator[None]:
        with catch_threading_exception() as cm:
            try:
>               yield

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/threadexception.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_call() -> Generator[None]:
>       yield from unraisable_exception_runtest_hook()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/unraisableexception.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def unraisable_exception_runtest_hook() -> Generator[None]:
        with catch_unraisable_exception() as cm:
            try:
>               yield

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/unraisableexception.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.logging.LoggingPlugin object at 0x11aff07d0>
item = <RuffItem ruff>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
>       yield from self._runtest_for(item, "call")

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/logging.py:846: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.logging.LoggingPlugin object at 0x11aff07d0>
item = <RuffItem ruff>, when = 'call'

    def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None]:
        """Implement the internals of the pytest_runtest_xxx() hooks."""
        with catching_logs(
            self.caplog_handler,
            level=self.log_level,
        ) as caplog_handler, catching_logs(
            self.report_handler,
            level=self.log_level,
        ) as report_handler:
            caplog_handler.reset()
            report_handler.reset()
            item.stash[caplog_records_key][when] = caplog_handler.records
            item.stash[caplog_handler_key] = caplog_handler
    
            try:
>               yield

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/logging.py:829: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <RuffItem ruff>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/capture.py:880: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <RuffItem ruff>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/skipping.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <RuffItem ruff>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/runner.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <RuffItem ruff>

    def runtest(self):
>       self.handler(path=self.fspath)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pytest_ruff/__init__.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <RuffItem ruff>
path = local('/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_upload.py')

    def handler(self, path):
>       return check_file(path)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pytest_ruff/__init__.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_upload.py')

    def check_file(path):
        ruff = find_ruff_bin()
        command = [
            ruff,
            "check",
            path,
            "--quiet",
            "--output-format=full",
            "--force-exclude",
        ]
        child = Popen(command, stdout=PIPE, stderr=PIPE)
        stdout, stderr = child.communicate()
    
        if child.returncode == 1:
>           raise RuffError(stdout.decode())
E           pytest_ruff.RuffError: tests/test_upload.py:351:9: ARG002 Unused method argument: `mock_dropbox_provider`
E               |
E           349 |         test_file: Path,
E           350 |         mock_s3_provider: MagicMock,
E           351 |         mock_dropbox_provider: MagicMock,
E               |         ^^^^^^^^^^^^^^^^^^^^^ ARG002
E           352 |     ) -> None:
E           353 |         """Test fallback to next provider on auth failure."""
E               |

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pytest_ruff/__init__.py:101: RuffError
______________________ TestFalIntegration.test_fal_setup _______________________
[gw0] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_integration.TestFalIntegration object at 0x121cd8b60>

    def test_fal_setup(self):
        """Test FAL provider setup check."""
>       success, explanation = setup_provider("fal")
E       TypeError: cannot unpack non-iterable ProviderInfo object

tests/test_integration.py:140: TypeError
________________ TestFalIntegration.test_fal_upload_small_file _________________
[gw0] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_integration.TestFalIntegration object at 0x121cd9f40>

    def test_fal_upload_small_file(self):
        """Test uploading a small file to FAL."""
        url = upload_file(SMALL_FILE, provider="fal")
>       assert url.startswith("https://")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x10db5c538>('https://')
E        +    where <built-in method startswith of str object at 0x10db5c538> = ''.startswith

tests/test_integration.py:147: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Failed to upload /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/data/test.txt using fal: FAL upload failed: expected str, bytes or os.PathLike object, not BufferedReader
________________ TestFalIntegration.test_fal_upload_large_file _________________
[gw0] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_integration.TestFalIntegration object at 0x121cda300>
large_test_file = PosixPath('/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/data/large_test.bin')

    def test_fal_upload_large_file(self, large_test_file):
        """Test uploading a large file to FAL."""
        start_time = time.time()
        url = upload_file(large_test_file, provider="fal")
        upload_time = time.time() - start_time
    
>       assert url.startswith("https://")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x10db5c538>('https://')
E        +    where <built-in method startswith of str object at 0x10db5c538> = ''.startswith

tests/test_integration.py:155: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Failed to upload /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/data/large_test.bin using fal: FAL upload failed: expected str, bytes or os.PathLike object, not BufferedReader
________________ TestProviderSetup.test_setup_provider_success _________________
[gw1] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderSetup object at 0x11ab03bf0>

    def test_setup_provider_success(self) -> None:
        """Test setup_provider with a valid provider."""
        result = setup_provider("simple")
>       assert result.success is True
E       assert False is True
E        +  where False = ProviderInfo(success=False, explanation="Provider 'simple' is not available.", help_info={}, timing=None).success

tests/test_upload.py:183: AssertionError
________________ TestProviderSetup.test_setup_provider_failure _________________
[gw1] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderSetup object at 0x11ab03f50>

    def test_setup_provider_failure(self) -> None:
        """Test setup_provider with an invalid provider."""
        result = setup_provider("invalid")
        assert result.success is False
>       assert "Provider not found" in result.explanation.lower()
E       assert 'Provider not found' in "provider 'invalid' is not available."
E        +  where "provider 'invalid' is not available." = <built-in method lower of str object at 0x11ace7960>()
E        +    where <built-in method lower of str object at 0x11ace7960> = "Provider 'invalid' is not available.".lower
E        +      where "Provider 'invalid' is not available." = ProviderInfo(success=False, explanation="Provider 'invalid' is not available.", help_info={}, timing=None).explanation

tests/test_upload.py:190: AssertionError
________________ TestProviderAuth.test_s3_auth_with_credentials ________________
[gw3] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderAuth object at 0x11a9512b0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x11aac96d0>

    def test_s3_auth_with_credentials(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test S3 auth when credentials are present."""
        monkeypatch.setenv("AWS_ACCESS_KEY_ID", "test_key")
        monkeypatch.setenv("AWS_SECRET_ACCESS_KEY", "test_secret")
        monkeypatch.setenv("AWS_DEFAULT_REGION", "us-east-1")
        monkeypatch.setenv("AWS_S3_BUCKET", "test-bucket")
    
        creds = s3.get_credentials()
        assert creds is not None
>       assert creds["bucket"] == "test-bucket"
E       KeyError: 'bucket'

tests/test_upload.py:263: KeyError
____________ TestProviderAuth.test_s3_auth_with_invalid_credentials ____________
[gw3] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderAuth object at 0x11a951970>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x11aac9880>

    def test_s3_auth_with_invalid_credentials(
        self, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Test S3 auth when credentials are invalid."""
        monkeypatch.setenv("AWS_ACCESS_KEY_ID", "invalid_key")
        monkeypatch.setenv("AWS_SECRET_ACCESS_KEY", "invalid_secret")
        monkeypatch.setenv("AWS_DEFAULT_REGION", "us-east-1")
        monkeypatch.setenv("AWS_S3_BUCKET", "test-bucket")
    
        creds = s3.get_credentials()
        assert creds is not None
    
        with patch("boto3.client") as mock_client:
            mock_s3 = mock_client.return_value
            mock_s3.head_bucket.side_effect = ClientError(
                {"Error": {"Code": "InvalidAccessKeyId", "Message": "Invalid key"}},
                "HeadBucket",
            )
            provider = s3.get_provider()
>           assert provider is None
E           assert <twat_fs.upload_providers.s3.S3Provider object at 0x11ab90fe0> is None

tests/test_upload.py:299: AssertionError
___________ TestAwsCredentialProviders.test_environment_credentials ____________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_s3_advanced.TestAwsCredentialProviders object at 0x1227a57f0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x1237a12e0>

>   ???
E   KeyError: 'bucket'

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/twat_fs/tests/test_s3_advanced.py:39: KeyError
___________ TestAwsCredentialProviders.test_shared_credentials_file ____________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_s3_advanced.TestAwsCredentialProviders object at 0x1227a5670>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_shared_credentials_file0')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x12380fc20>

>   ???
E   KeyError: 'bucket'

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/twat_fs/tests/test_s3_advanced.py:64: KeyError
_________________ TestAwsCredentialProviders.test_assume_role __________________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_s3_advanced.TestAwsCredentialProviders object at 0x1227a4fe0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x123757320>

>   ???
E   KeyError: 'role_arn'

/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/twat_fs/tests/test_s3_advanced.py:80: KeyError
_________________ TestUploadFile.test_upload_with_s3_provider __________________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestUploadFile object at 0x123669e20>
test_file = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_upload_with_s3_provider0/test.txt')
mock_s3_provider = <MagicMock name='S3Provider' id='4889742176'>

    def test_upload_with_s3_provider(
        self, test_file: Path, mock_s3_provider: MagicMock
    ) -> None:
        """Test upload with S3 provider."""
        url = upload_file(test_file, provider="s3")
>       assert url == TEST_URL
E       AssertionError: assert <MagicMock name='S3Provider.get_provider().upload_file().url' id='4890499392'> == 'https://example.com/test.txt'

tests/test_upload.py:463: AssertionError
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=0.01s, read=0.00s, upload=0.00s, validation=0.01s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: Invalid URL "<MagicMock name='S3Provider.get_provider().upload_file()' id='4890236000'>": No scheme supplied. Perhaps you meant https://<MagicMock name='S3Provider.get_provider().upload_file()' id='4890236000'>?
____________________ TestUploadFile.test_s3_upload_failure _____________________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestUploadFile object at 0x123668590>
test_file = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_s3_upload_failure0/test.txt')
mock_s3_provider = <MagicMock name='S3Provider' id='4891190208'>

    def test_s3_upload_failure(
        self, test_file: Path, mock_s3_provider: MagicMock
    ) -> None:
        """Test S3 upload failure."""
        mock_s3_provider.side_effect = ClientError(
            {"Error": {"Code": "NoSuchBucket", "Message": "Bucket does not exist"}},
            "PutObject",
        )
>       with pytest.raises(
            ValueError, match="An error occurred .* Bucket does not exist"
        ):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_upload.py:480: Failed
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=0.01s, read=0.00s, upload=0.00s, validation=0.00s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: Invalid URL "<MagicMock name='S3Provider.get_provider().upload_file()' id='4891591840'>": No scheme supplied. Perhaps you meant https://<MagicMock name='S3Provider.get_provider().upload_file()' id='4891591840'>?
________________ TestSetupIntegration.test_setup_all_providers _________________
[gw0] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_integration.TestSetupIntegration object at 0x121cda7e0>

    def test_setup_all_providers(self) -> None:
        """Test checking setup status for all providers."""
        # setup_providers() returns None, we just check it runs without errors
        setup_providers()
    
        # We can still test individual providers
        for provider in PROVIDERS_PREFERENCE:
            if provider.lower() == "simple":
                continue
            result = setup_provider(provider)
            # At least one provider should be available or have setup instructions
>           assert result.success or (
                "not configured" in result.explanation
                or "setup" in result.explanation.lower()
            )
E           assert (False or ('not configured' in "Provider 's3' needs configuration." or 'setup' in "provider 's3' needs configuration."))
E            +  where False = ProviderInfo(success=False, explanation="Provider 's3' needs configuration.", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).success
E            +  and   "Provider 's3' needs configuration." = ProviderInfo(success=False, explanation="Provider 's3' needs configuration.", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).explanation
E            +  and   "provider 's3' needs configuration." = <built-in method lower of str object at 0x122c68080>()
E            +    where <built-in method lower of str object at 0x122c68080> = "Provider 's3' needs configuration.".lower
E            +      where "Provider 's3' needs configuration." = ProviderInfo(success=False, explanation="Provider 's3' needs configuration.", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).explanation

tests/test_integration.py:173: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Failed to get account info: AuthError('dd800da8b38240f7b9bd81fc17ae58b7', AuthError('expired_access_token', None))
Error: Dropbox token has expired and cannot be refreshed automatically.
To enable automatic token refresh:
1. Set DROPBOX_REFRESH_TOKEN environment variable
2. Set DROPBOX_APP_KEY environment variable
For now, please generate a new access token.
------------------------------ Captured log call -------------------------------
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
INFO     dropbox:dropbox_client.py:488 ExpiredCredentials status_code=401: Refreshing and Retrying
WARNING  dropbox:dropbox_client.py:386 Unable to refresh access token without                 refresh token and app key
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
________________ TestProviderSetup.test_setup_provider_dropbox _________________
[gw1] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderSetup object at 0x11ab02f60>

    def test_setup_provider_dropbox(self) -> None:
        """Test setup_provider with Dropbox."""
        result = setup_provider("dropbox")
        # Test should pass if either:
        # 1. Provider is properly configured (success is True)
        # 2. Provider needs setup (success is False and explanation contains setup instructions)
>       assert result.success is True or (
            result.success is False
            and "DROPBOX_ACCESS_TOKEN" in result.explanation
            and "setup" in result.explanation.lower()
        )
E       assert (False is True or (False is False and 'DROPBOX_ACCESS_TOKEN' in "Provider 'dropbox' needs configuration."))
E        +  where False = ProviderInfo(success=False, explanation="Provider 'dropbox' needs configuration.", help_info={'setup': "To use Dropbox storage:\n1. Create a Dropbox account if you don't have one\n2. Go to https://www.dropbox.com/developers/apps\n3. Create a new app or use an existing one\n4. Generate an access token from the app console\n5. Set the following environment variables:\n   - DROPBOX_ACCESS_TOKEN: Your Dropbox access token\n   Optional:\n   - DROPBOX_REFRESH_TOKEN: OAuth2 refresh token\n   - DROPBOX_APP_KEY: Dropbox app key\n   - DROPBOX_APP_SECRET: Dropbox app secret"}, timing=None).success
E        +  and   False = ProviderInfo(success=False, explanation="Provider 'dropbox' needs configuration.", help_info={'setup': "To use Dropbox storage:\n1. Create a Dropbox account if you don't have one\n2. Go to https://www.dropbox.com/developers/apps\n3. Create a new app or use an existing one\n4. Generate an access token from the app console\n5. Set the following environment variables:\n   - DROPBOX_ACCESS_TOKEN: Your Dropbox access token\n   Optional:\n   - DROPBOX_REFRESH_TOKEN: OAuth2 refresh token\n   - DROPBOX_APP_KEY: Dropbox app key\n   - DROPBOX_APP_SECRET: Dropbox app secret"}, timing=None).success
E        +  and   "Provider 'dropbox' needs configuration." = ProviderInfo(success=False, explanation="Provider 'dropbox' needs configuration.", help_info={'setup': "To use Dropbox storage:\n1. Create a Dropbox account if you don't have one\n2. Go to https://www.dropbox.com/developers/apps\n3. Create a new app or use an existing one\n4. Generate an access token from the app console\n5. Set the following environment variables:\n   - DROPBOX_ACCESS_TOKEN: Your Dropbox access token\n   Optional:\n   - DROPBOX_REFRESH_TOKEN: OAuth2 refresh token\n   - DROPBOX_APP_KEY: Dropbox app key\n   - DROPBOX_APP_SECRET: Dropbox app secret"}, timing=None).explanation

tests/test_upload.py:199: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Failed to get account info: AuthError('29301ae908284fe2bd6f8571dd45854b', AuthError('expired_access_token', None))
Error: Dropbox token has expired and cannot be refreshed automatically.
To enable automatic token refresh:
1. Set DROPBOX_REFRESH_TOKEN environment variable
2. Set DROPBOX_APP_KEY environment variable
For now, please generate a new access token.
------------------------------ Captured log call -------------------------------
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
INFO     dropbox:dropbox_client.py:488 ExpiredCredentials status_code=401: Refreshing and Retrying
WARNING  dropbox:dropbox_client.py:386 Unable to refresh access token without                 refresh token and app key
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
________________ TestUploadFile.test_upload_with_provider_list _________________
[gw1] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestUploadFile object at 0x11ab0a570>
test_file = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_upload_with_provider_list0/test.txt')
mock_s3_provider = <MagicMock name='S3Provider' id='4742712304'>

    def test_upload_with_provider_list(
        self, test_file: Path, mock_s3_provider: MagicMock
    ) -> None:
        """Test upload with provider list."""
        url = upload_file(test_file, provider=["s3", "dropbox"])
>       assert url == TEST_URL
E       AssertionError: assert <MagicMock name='S3Provider.get_provider().upload_file().url' id='4743788496'> == 'https://example.com/test.txt'

tests/test_upload.py:338: AssertionError
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=0.01s, read=0.00s, upload=0.00s, validation=0.00s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: Invalid URL "<MagicMock name='S3Provider.get_provider().upload_file()' id='4742717056'>": No scheme supplied. Perhaps you meant https://<MagicMock name='S3Provider.get_provider().upload_file()' id='4742717056'>?
____________________ TestEdgeCases.test_no_read_permission _____________________
[gw1] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestEdgeCases object at 0x11ab19040>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_no_read_permission0')

    def test_no_read_permission(self, tmp_path: Path) -> None:
        """Test uploading a file without read permission."""
        test_file = tmp_path / "noperm.txt"
        test_file.write_text("test content")
        test_file.chmod(0o000)  # Remove all permissions
    
>       with pytest.raises(PermissionError):
E       Failed: DID NOT RAISE <class 'PermissionError'>

tests/test_upload.py:590: Failed
________________________ TestEdgeCases.test_empty_file _________________________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <MagicMock name='get_provider().upload_file' id='4891495120'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), 'remote_path': None, 'unique': False, ...}
expected = call(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), remote_path=None, unique=False, force=False, upload_path=None)
actual = call(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), None, unique=False, force=False, upload_path=None)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x1237c8400>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), None, unique=False, force=False, upload_path=None)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:949: AssertionError

During handling of the above exception, another exception occurred:

self = <MagicMock name='get_provider().upload_file' id='4891495120'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), 'remote_path': None, 'unique': False, ...}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
E       AssertionError: expected call not found.
E       Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E         Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), None, unique=False, force=False, upload_path=None)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert (PosixPath('/...y.txt'), None) == ()
E         
E         Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt')
E         
E         Full diff:
E         - ()
E         + (
E         +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'),
E         +     None,
E         + )
E       Kwargs:
E       assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E         
E         Omitting 3 identical items, use -vv to show
E         Right contains 2 more items:
E         {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'),
E          'remote_path': None}
E         
E         Full diff:...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:961: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_upload.TestEdgeCases object at 0x12366be30>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0')

    def test_empty_file(self, tmp_path: Path) -> None:
        """Test uploading an empty file."""
        test_file = tmp_path / "empty.txt"
        test_file.touch()
    
        with patch("twat_fs.upload_providers.s3.get_provider") as mock_provider:
            client = MagicMock()
            client.upload_file.return_value = TEST_URL
            mock_provider.return_value = client
    
            url = upload_file(test_file, provider="s3")
            assert url == TEST_URL
    
>           client.upload_file.assert_called_once_with(
                local_path=test_file,
                remote_path=None,
                unique=False,
                force=False,
                upload_path=None,
            )
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'), None, unique=False, force=False, upload_path=None)
E           
E           pytest introspection follows:
E           
E           Args:
E           assert (PosixPath('/...y.txt'), None) == ()
E             
E             Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt')
E             
E             Full diff:
E             - ()
E             + (
E             +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'),
E             +     None,
E             + )
E           Kwargs:
E           assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E             
E             Omitting 3 identical items, use -vv to show
E             Right contains 2 more items:
E             {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_empty_file0/empty.txt'),
E              'remote_path': None}
E             
E             Full diff:...
E             
E             ...Full output truncated (7 lines hidden), use '-vv' to show

tests/test_upload.py:502: AssertionError
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=0.83s, read=0.00s, upload=0.00s, validation=0.83s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: status 404
____________________ TestEdgeCases.test_very_long_filename _____________________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestEdgeCases object at 0x123678980>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_very_long_filename0')

    def test_very_long_filename(self, tmp_path: Path) -> None:
        """Test uploading a file with a very long name."""
        long_name = "a" * 255 + ".txt"  # Max filename length on most filesystems
        test_file = tmp_path / long_name
>       test_file.write_text("test content")

tests/test_upload.py:556: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pathlib.py:1047: in write_text
    with self.open(mode='w', encoding=encoding, errors=errors, newline=newline) as f:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_very_long_...aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.txt')
mode = 'w', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed to by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return io.open(self, mode, buffering, encoding, errors, newline)
E       OSError: [Errno 63] File name too long: '/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_very_long_filename0/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.txt'

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pathlib.py:1013: OSError
_______________ TestUploadFile.test_upload_with_default_provider _______________
[gw0] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestUploadFile object at 0x122b759a0>
test_file = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw0/test_upload_with_default_provi0/test.txt')
mock_s3_provider = <MagicMock name='S3Provider' id='4878607824'>

    def test_upload_with_default_provider(
        self, test_file: Path, mock_s3_provider: MagicMock
    ) -> None:
        """Test upload with default provider."""
        url = upload_file(test_file)
>       assert url == TEST_URL
E       AssertionError: assert 'https://litt...oe/xwxitg.txt' == 'https://example.com/test.txt'
E         
E         - https://example.com/test.txt
E         + https://litter.catbox.moe/xwxitg.txt

tests/test_upload.py:310: AssertionError
----------------------------- Captured stdout call -----------------------------
Successfully uploaded /private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw0/test_upload_with_default_provi0/test.txt using litterbox
Upload timing for litterbox: total=1.42s, read=0.00s, upload=0.72s, validation=0.70s
____________________ TestUploadFile.test_all_providers_fail ____________________
[gw3] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestUploadFile object at 0x11a9532f0>
test_file = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_all_providers_fail0/test.txt')

    def test_all_providers_fail(self, test_file: Path) -> None:
        """Test error when all providers fail."""
        with (
            patch("twat_fs.upload_providers.fal.get_provider") as mock_fal,
            patch("twat_fs.upload_providers.dropbox.get_provider") as mock_dropbox,
            patch("twat_fs.upload_providers.s3.get_provider") as mock_s3,
            patch("twat_fs.upload_providers.www0x0.get_provider") as mock_www0x0,
            patch("twat_fs.upload_providers.uguu.get_provider") as mock_uguu,
            patch(
                "twat_fs.upload_providers.bashupload.get_provider"
            ) as mock_bashupload,
        ):
            # Make all providers fail
            mock_fal.return_value = None
            mock_dropbox.return_value = None
            mock_s3.return_value = None
            mock_www0x0.return_value = None
            mock_uguu.return_value = None
            mock_bashupload.return_value = None
    
>           with pytest.raises(
                ValueError, match="No provider available or all providers failed"
            ):
E           Failed: DID NOT RAISE <class 'ValueError'>

tests/test_upload.py:448: Failed
----------------------------- Captured stdout call -----------------------------
Successfully uploaded /private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_all_providers_fail0/test.txt using litterbox
Upload timing for litterbox: total=1.58s, read=0.00s, upload=0.73s, validation=0.84s
_____________ TestCatboxProvider.test_catbox_auth_without_userhash _____________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestCatboxProvider object at 0x12367a270>

    def test_catbox_auth_without_userhash(self):
        """Test Catbox provider without userhash."""
        provider = catbox.CatboxProvider()
>       assert provider.userhash is None
E       AttributeError: 'CatboxProvider' object has no attribute 'userhash'

tests/test_upload.py:628: AttributeError
______________________________ Black format check ______________________________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python
--- /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_twat_fs.py	2025-02-14 21:27:44.604233+00:00
+++ /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_twat_fs.py	2025-03-04 07:20:58.382273+00:00
@@ -1,6 +1,7 @@
 """Test suite for twat_fs."""
+
 # this_file: tests/test_package.py
 
 
 def test_version():
     """Verify package exposes version."""

______________ TestUploadFile.test_upload_with_specific_provider _______________
[gw0] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestUploadFile object at 0x122b75d90>
test_file = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw0/test_upload_with_specific_prov0/test.txt')
mock_s3_provider = <MagicMock name='S3Provider' id='4878445472'>

    def test_upload_with_specific_provider(
        self, test_file: Path, mock_s3_provider: MagicMock
    ) -> None:
        """Test upload with specific provider."""
        url = upload_file(test_file, provider="s3")
>       assert url == TEST_URL
E       AssertionError: assert <MagicMock name='S3Provider.get_provider().upload_file().url' id='4878225472'> == 'https://example.com/test.txt'

tests/test_upload.py:324: AssertionError
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=0.01s, read=0.00s, upload=0.00s, validation=0.00s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: Invalid URL "<MagicMock name='S3Provider.get_provider().upload_file()' id='4878802128'>": No scheme supplied. Perhaps you meant https://<MagicMock name='S3Provider.get_provider().upload_file()' id='4878802128'>?
__________________ TestCatboxProvider.test_catbox_upload_file __________________
[gw5] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestCatboxProvider object at 0x12367a600>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_catbox_upload_file0')

    @pytest.mark.asyncio
    async def test_catbox_upload_file(self, tmp_path):
        """Test file upload to Catbox."""
        test_file = tmp_path / "test.txt"
        test_file.write_text("test content")
    
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.text = AsyncMock(
            return_value="https://files.catbox.moe/abc123.txt"
        )
    
        mock_session = AsyncMock()
        mock_session.post = AsyncMock()
        mock_session.post.return_value.__aenter__.return_value = mock_response
    
        with patch("aiohttp.ClientSession", return_value=mock_session):
            provider = catbox.CatboxProvider()
            result = await provider.async_upload_file(
                test_file,
                remote_path=None,
                unique=False,
                force=False,
                upload_path=None,
            )
            assert isinstance(result, UploadResult)
>           assert result.url == "https://files.catbox.moe/abc123.txt"
E           AssertionError: assert 'file:///priv...ile0/test.txt' == 'https://file...oe/abc123.txt'
E             
E             - https://files.catbox.moe/abc123.txt
E             + file:///private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw5/test_catbox_upload_file0/test.txt

tests/test_upload.py:656: AssertionError
__________________ TestCatboxProvider.test_catbox_upload_url ___________________
[gw0] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestCatboxProvider object at 0x122b77170>

    @pytest.mark.asyncio
    async def test_catbox_upload_url(self):
        """Test URL upload to Catbox."""
        test_url = "https://example.com/image.jpg"
    
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.text = AsyncMock(
            return_value="https://files.catbox.moe/xyz789.jpg"
        )
    
        mock_session = AsyncMock()
        mock_session.post = AsyncMock()
        mock_session.post.return_value.__aenter__.return_value = mock_response
    
        with patch("aiohttp.ClientSession", return_value=mock_session):
>           provider = catbox.CatboxProvider({"userhash": "test_hash"})
E           TypeError: CatboxProvider() takes no arguments

tests/test_upload.py:674: TypeError
________________ TestProviderSetup.test_setup_working_provider _________________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderSetup object at 0x11e6fa060>
mock_s3_provider = <MagicMock name='S3Provider' id='4809461056'>

    def test_setup_working_provider(self, mock_s3_provider: MagicMock) -> None:
        """Test setup check for a working provider."""
        assert mock_s3_provider is not None  # Verify fixture is used
        result = setup_provider("s3")
>       assert result.success is True
E       assert False is True
E        +  where False = ProviderInfo(success=False, explanation="Provider 's3' setup failed: type object 'MagicMock' has no attribute 'async_upload_file'", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).success

tests/test_upload.py:82: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Error setting up provider s3: type object 'MagicMock' has no attribute 'async_upload_file'
_______________ TestProviderSetup.test_setup_missing_credentials _______________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderSetup object at 0x11e6fa3c0>

    def test_setup_missing_credentials(self) -> None:
        """Test setup check when credentials are missing."""
        with patch("twat_fs.upload_providers.s3.get_credentials") as mock_creds:
            mock_creds.return_value = None
            result = setup_provider("s3")
            assert result.success is False
>           assert "not configured" in result.explanation
E           assert 'not configured' in "Provider 's3' needs configuration."
E            +  where "Provider 's3' needs configuration." = ProviderInfo(success=False, explanation="Provider 's3' needs configuration.", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).explanation

tests/test_upload.py:91: AssertionError
_______________ TestLitterboxProvider.test_litterbox_upload_file _______________
[gw0] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestLitterboxProvider object at 0x122b827e0>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw0/test_litterbox_upload_file0')

    @pytest.mark.asyncio
    async def test_litterbox_upload_file(self, tmp_path):
        """Test file upload to Litterbox."""
        test_file = tmp_path / "test.txt"
        test_file.write_text("test content")
    
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.text = AsyncMock(
            return_value="https://litterbox.catbox.moe/abc123.txt"
        )
    
        mock_session = AsyncMock()
        mock_session.post = AsyncMock()
        mock_session.post.return_value.__aenter__.return_value = mock_response
    
        with patch("aiohttp.ClientSession", return_value=mock_session):
            provider = litterbox.LitterboxProvider()
            result = await provider.async_upload_file(
                test_file,
                remote_path=None,
                unique=False,
                force=False,
                upload_path=None,
                expiration=litterbox.ExpirationTime.HOURS_12,
            )
            assert isinstance(result, UploadResult)
>           assert result.url == "https://litterbox.catbox.moe/abc123.txt"
E           AssertionError: assert 'file:///priv...ile0/test.txt' == 'https://litt...oe/abc123.txt'
E             
E             - https://litterbox.catbox.moe/abc123.txt
E             + file:///private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw0/test_litterbox_upload_file0/test.txt

tests/test_upload.py:731: AssertionError
______________ TestProviderSetup.test_setup_missing_dependencies _______________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderSetup object at 0x11e6fa720>

    def test_setup_missing_dependencies(self) -> None:
        """Test setup check when dependencies are missing."""
        with patch("twat_fs.upload_providers.s3.get_credentials") as mock_creds:
            with patch("twat_fs.upload_providers.s3.get_provider") as mock_provider:
                mock_creds.return_value = {
                    "bucket": "test-bucket",
                    "aws_access_key_id": "test_key",
                    "aws_secret_access_key": "test_secret",
                }
                mock_provider.return_value = None
                result = setup_provider("s3")
                assert result.success is False
>               assert "additional setup is needed" in result.explanation
E               assert 'additional setup is needed' in "Provider 's3' needs configuration."
E                +  where "Provider 's3' needs configuration." = ProviderInfo(success=False, explanation="Provider 's3' needs configuration.", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).explanation

tests/test_upload.py:107: AssertionError
______________________________ test_fragile_mode _______________________________
[gw0] darwin -- Python 3.12.8 /usr/local/bin/python

test_file = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw0/test_fragile_mode0/test.txt')
mock_s3_provider = <MagicMock name='S3Provider' id='4880321376'>

    def test_fragile_mode(
        test_file: Path,
        mock_s3_provider: MagicMock,
    ) -> None:
        """Test that fragile mode fails immediately without fallback."""
        # Make S3 provider fail
        mock_s3_provider.upload_file.side_effect = RetryableError("S3 failed", "s3")
    
        # Should raise immediately in fragile mode
>       with pytest.raises(NonRetryableError) as exc_info:
E       Failed: DID NOT RAISE <class 'twat_fs.upload_providers.core.NonRetryableError'>

tests/test_upload.py:770: Failed
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=0.01s, read=0.01s, upload=0.00s, validation=0.00s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: Invalid URL "<MagicMock name='S3Provider.get_provider().upload_file()' id='4880463008'>": No scheme supplied. Perhaps you meant https://<MagicMock name='S3Provider.get_provider().upload_file()' id='4880463008'>?
__________________ TestEdgeCases.test_different_file_sizes[1] __________________
[gw1] darwin -- Python 3.12.8 /usr/local/bin/python

self = <MagicMock name='get_provider().upload_file' id='4745235008'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), 'remote_path': None, 'unique': False, ...}
expected = call(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
actual = call(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), None, unique=False, force=False, upload_path=None)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x11ac0ec00>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), None, unique=False, force=False, upload_path=None)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:949: AssertionError

During handling of the above exception, another exception occurred:

self = <MagicMock name='get_provider().upload_file' id='4745235008'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), 'remote_path': None, 'unique': False, ...}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
E       AssertionError: expected call not found.
E       Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E         Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), None, unique=False, force=False, upload_path=None)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert (PosixPath('/...b.txt'), None) == ()
E         
E         Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt')
E         
E         Full diff:
E         - ()
E         + (
E         +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'),
E         +     None,
E         + )
E       Kwargs:
E       assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E         
E         Omitting 3 identical items, use -vv to show
E         Right contains 2 more items:
E         {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'),
E          'remote_path': None}
E         
E         Full diff:...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:961: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_upload.TestEdgeCases object at 0x11ab193d0>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0')
size_mb = 1

    @pytest.mark.parametrize("size_mb", [1, 5, 10])
    def test_different_file_sizes(self, tmp_path: Path, size_mb: int) -> None:
        """Test uploading files of different sizes."""
        test_file = tmp_path / f"test_{size_mb}mb.txt"
        with test_file.open("wb") as f:
            f.write(b"0" * (size_mb * 1024 * 1024))
    
        with patch("twat_fs.upload_providers.s3.get_provider") as mock_provider:
            client = MagicMock()
            client.upload_file.return_value = TEST_URL
            mock_provider.return_value = client
    
            url = upload_file(test_file, provider="s3")
            assert url == TEST_URL
    
>           client.upload_file.assert_called_once_with(
                local_path=test_file,
                remote_path=None,
                unique=False,
                force=False,
                upload_path=None,
            )
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'), None, unique=False, force=False, upload_path=None)
E           
E           pytest introspection follows:
E           
E           Args:
E           assert (PosixPath('/...b.txt'), None) == ()
E             
E             Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt')
E             
E             Full diff:
E             - ()
E             + (
E             +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'),
E             +     None,
E             + )
E           Kwargs:
E           assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E             
E             Omitting 3 identical items, use -vv to show
E             Right contains 2 more items:
E             {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_1_0/test_1mb.txt'),
E              'remote_path': None}
E             
E             Full diff:...
E             
E             ...Full output truncated (7 lines hidden), use '-vv' to show

tests/test_upload.py:608: AssertionError
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=1.07s, read=0.00s, upload=0.00s, validation=1.07s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: status 404
_________________________________ test session _________________________________
[gw4] darwin -- Python 3.12.8 /usr/local/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x11ea73560>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flaky/flaky_pytest_plugin.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>, kwargs = {'item': <RuffItem ruff>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_hooks.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x109bbc7d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_manager.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x11eb22fe0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_result.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_call() -> Generator[None]:
>       yield from thread_exception_runtest_hook()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/threadexception.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def thread_exception_runtest_hook() -> Generator[None]:
        with catch_threading_exception() as cm:
            try:
>               yield

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/threadexception.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @pytest.hookimpl(wrapper=True, tryfirst=True)
    def pytest_runtest_call() -> Generator[None]:
>       yield from unraisable_exception_runtest_hook()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/unraisableexception.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def unraisable_exception_runtest_hook() -> Generator[None]:
        with catch_unraisable_exception() as cm:
            try:
>               yield

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/unraisableexception.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.logging.LoggingPlugin object at 0x11c13b620>
item = <RuffItem ruff>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")
    
>       yield from self._runtest_for(item, "call")

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/logging.py:846: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.logging.LoggingPlugin object at 0x11c13b620>
item = <RuffItem ruff>, when = 'call'

    def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None]:
        """Implement the internals of the pytest_runtest_xxx() hooks."""
        with catching_logs(
            self.caplog_handler,
            level=self.log_level,
        ) as caplog_handler, catching_logs(
            self.report_handler,
            level=self.log_level,
        ) as report_handler:
            caplog_handler.reset()
            report_handler.reset()
            item.stash[caplog_records_key][when] = caplog_handler.records
            item.stash[caplog_handler_key] = caplog_handler
    
            try:
>               yield

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/logging.py:829: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <RuffItem ruff>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/capture.py:880: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                        except StopIteration:
                            pass
                        except BaseException as e:
                            _warn_teardown_exception(hook_name, teardown[1], e)
                            raise
                        else:
                            _raise_wrapfail(teardown[0], "has second yield")
                    else:
                        try:
                            if outcome._exception is not None:
>                               teardown.throw(outcome._exception)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <RuffItem ruff>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)
    
        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)
    
        try:
>           return (yield)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/skipping.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/Library/Frameworks/Python.framework/Versions/3...pper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>>, ...]
caller_kwargs = {'item': <RuffItem ruff>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen, hook_impl))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pluggy/_callers.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <RuffItem ruff>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/_pytest/runner.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <RuffItem ruff>

    def runtest(self):
>       self.handler(path=self.fspath)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pytest_ruff/__init__.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <RuffItem ruff>
path = local('/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_utils.py')

    def handler(self, path):
>       return check_file(path)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pytest_ruff/__init__.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_fs/tests/test_utils.py')

    def check_file(path):
        ruff = find_ruff_bin()
        command = [
            ruff,
            "check",
            path,
            "--quiet",
            "--output-format=full",
            "--force-exclude",
        ]
        child = Popen(command, stdout=PIPE, stderr=PIPE)
        stdout, stderr = child.communicate()
    
        if child.returncode == 1:
>           raise RuffError(stdout.decode())
E           pytest_ruff.RuffError: tests/test_utils.py:104:55: ARG002 Unused method argument: `mock_access`
E               |
E           103 |     @mock.patch("os.access", return_value=False)
E           104 |     def test_validate_file_with_unreadable_file(self, mock_access):
E               |                                                       ^^^^^^^^^^^ ARG002
E           105 |         """Test that validate_file raises PermissionError for unreadable files."""
E           106 |         with tempfile.NamedTemporaryFile(delete=False) as temp_file:
E               |
E           
E           tests/test_utils.py:340:62: FBT003 Boolean positional value in function call
E               |
E           338 |     def test_log_upload_attempt_success(self, mock_logger_info):
E           339 |         """Test that log_upload_attempt logs success correctly."""
E           340 |         log_upload_attempt("test_provider", "test_file.txt", True)
E               |                                                              ^^^^ FBT003
E           341 |
E           342 |         mock_logger_info.assert_called_once()
E               |
E           
E           tests/test_utils.py:349:62: FBT003 Boolean positional value in function call
E               |
E           347 |         """Test that log_upload_attempt logs failure correctly."""
E           348 |         error = Exception("Test error")
E           349 |         log_upload_attempt("test_provider", "test_file.txt", False, error)
E               |                                                              ^^^^^ FBT003
E           350 |
E           351 |         mock_logger_error.assert_called_once()
E               |

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/pytest_ruff/__init__.py:101: RuffError
______________ TestEdgeCases.test_special_characters_in_filename _______________
[gw3] darwin -- Python 3.12.8 /usr/local/bin/python

self = <MagicMock name='get_provider().upload_file' id='4741963056'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), 'remote_path': None, 'unique': False, ...}
expected = call(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), remote_path=None, unique=False, force=False, upload_path=None)
actual = call(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), None, unique=False, force=False, upload_path=None)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x11ab3d940>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), None, unique=False, force=False, upload_path=None)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:949: AssertionError

During handling of the above exception, another exception occurred:

self = <MagicMock name='get_provider().upload_file' id='4741963056'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), 'remote_path': None, 'unique': False, ...}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
E       AssertionError: expected call not found.
E       Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E         Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), None, unique=False, force=False, upload_path=None)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert (PosixPath('/...*.txt'), None) == ()
E         
E         Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt')
E         
E         Full diff:
E         - ()
E         + (
E         +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'),
E         +     None,
E         + )
E       Kwargs:
E       assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E         
E         Omitting 3 identical items, use -vv to show
E         Right contains 2 more items:
E         {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'),
E          'remote_path': None}
E         
E         Full diff:...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:961: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_upload.TestEdgeCases object at 0x11a953f50>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0')

    def test_special_characters_in_filename(self, tmp_path: Path) -> None:
        """Test uploading a file with special characters in the name."""
        test_file = tmp_path / "test!@#$%^&*.txt"
        test_file.write_text("test content")
    
        with patch("twat_fs.upload_providers.s3.get_provider") as mock_provider:
            client = MagicMock()
            client.upload_file.return_value = TEST_URL
            mock_provider.return_value = client
    
            url = upload_file(test_file, provider="s3")
            assert url == TEST_URL
    
>           client.upload_file.assert_called_once_with(
                local_path=test_file,
                remote_path=None,
                unique=False,
                force=False,
                upload_path=None,
            )
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'), None, unique=False, force=False, upload_path=None)
E           
E           pytest introspection follows:
E           
E           Args:
E           assert (PosixPath('/...*.txt'), None) == ()
E             
E             Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt')
E             
E             Full diff:
E             - ()
E             + (
E             +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'),
E             +     None,
E             + )
E           Kwargs:
E           assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E             
E             Omitting 3 identical items, use -vv to show
E             Right contains 2 more items:
E             {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_special_characters_in_fil0/test!@#$%^&*.txt'),
E              'remote_path': None}
E             
E             Full diff:...
E             
E             ...Full output truncated (7 lines hidden), use '-vv' to show

tests/test_upload.py:523: AssertionError
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=1.27s, read=0.00s, upload=0.00s, validation=1.27s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: status 404
__________________ TestEdgeCases.test_different_file_sizes[5] __________________
[gw1] darwin -- Python 3.12.8 /usr/local/bin/python

self = <MagicMock name='get_provider().upload_file' id='4744985584'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), 'remote_path': None, 'unique': False, ...}
expected = call(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
actual = call(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), None, unique=False, force=False, upload_path=None)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x11ac0c180>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), None, unique=False, force=False, upload_path=None)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:949: AssertionError

During handling of the above exception, another exception occurred:

self = <MagicMock name='get_provider().upload_file' id='4744985584'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), 'remote_path': None, 'unique': False, ...}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
E       AssertionError: expected call not found.
E       Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E         Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), None, unique=False, force=False, upload_path=None)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert (PosixPath('/...b.txt'), None) == ()
E         
E         Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt')
E         
E         Full diff:
E         - ()
E         + (
E         +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'),
E         +     None,
E         + )
E       Kwargs:
E       assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E         
E         Omitting 3 identical items, use -vv to show
E         Right contains 2 more items:
E         {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'),
E          'remote_path': None}
E         
E         Full diff:...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:961: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_upload.TestEdgeCases object at 0x11ab19610>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0')
size_mb = 5

    @pytest.mark.parametrize("size_mb", [1, 5, 10])
    def test_different_file_sizes(self, tmp_path: Path, size_mb: int) -> None:
        """Test uploading files of different sizes."""
        test_file = tmp_path / f"test_{size_mb}mb.txt"
        with test_file.open("wb") as f:
            f.write(b"0" * (size_mb * 1024 * 1024))
    
        with patch("twat_fs.upload_providers.s3.get_provider") as mock_provider:
            client = MagicMock()
            client.upload_file.return_value = TEST_URL
            mock_provider.return_value = client
    
            url = upload_file(test_file, provider="s3")
            assert url == TEST_URL
    
>           client.upload_file.assert_called_once_with(
                local_path=test_file,
                remote_path=None,
                unique=False,
                force=False,
                upload_path=None,
            )
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'), None, unique=False, force=False, upload_path=None)
E           
E           pytest introspection follows:
E           
E           Args:
E           assert (PosixPath('/...b.txt'), None) == ()
E             
E             Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt')
E             
E             Full diff:
E             - ()
E             + (
E             +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'),
E             +     None,
E             + )
E           Kwargs:
E           assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E             
E             Omitting 3 identical items, use -vv to show
E             Right contains 2 more items:
E             {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw1/test_different_file_sizes_5_0/test_5mb.txt'),
E              'remote_path': None}
E             
E             Full diff:...
E             
E             ...Full output truncated (7 lines hidden), use '-vv' to show

tests/test_upload.py:608: AssertionError
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=0.67s, read=0.01s, upload=0.00s, validation=0.66s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: status 404
_________________ TestEdgeCases.test_different_file_sizes[10] __________________
[gw7] darwin -- Python 3.12.8 /usr/local/bin/python

self = <MagicMock name='get_provider().upload_file' id='4891774608'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), 'remote_path': None, 'unique': False, ...}
expected = call(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
actual = call(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), None, unique=False, force=False, upload_path=None)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x123911800>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), None, unique=False, force=False, upload_path=None)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:949: AssertionError

During handling of the above exception, another exception occurred:

self = <MagicMock name='get_provider().upload_file' id='4891774608'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), 'remote_path': None, 'unique': False, ...}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
E       AssertionError: expected call not found.
E       Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E         Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), None, unique=False, force=False, upload_path=None)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert (PosixPath('/...b.txt'), None) == ()
E         
E         Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt')
E         
E         Full diff:
E         - ()
E         + (
E         +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'),
E         +     None,
E         + )
E       Kwargs:
E       assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E         
E         Omitting 3 identical items, use -vv to show
E         Right contains 2 more items:
E         {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'),
E          'remote_path': None}
E         
E         Full diff:...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:961: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_upload.TestEdgeCases object at 0x123899790>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0')
size_mb = 10

    @pytest.mark.parametrize("size_mb", [1, 5, 10])
    def test_different_file_sizes(self, tmp_path: Path, size_mb: int) -> None:
        """Test uploading files of different sizes."""
        test_file = tmp_path / f"test_{size_mb}mb.txt"
        with test_file.open("wb") as f:
            f.write(b"0" * (size_mb * 1024 * 1024))
    
        with patch("twat_fs.upload_providers.s3.get_provider") as mock_provider:
            client = MagicMock()
            client.upload_file.return_value = TEST_URL
            mock_provider.return_value = client
    
            url = upload_file(test_file, provider="s3")
            assert url == TEST_URL
    
>           client.upload_file.assert_called_once_with(
                local_path=test_file,
                remote_path=None,
                unique=False,
                force=False,
                upload_path=None,
            )
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'), None, unique=False, force=False, upload_path=None)
E           
E           pytest introspection follows:
E           
E           Args:
E           assert (PosixPath('/...b.txt'), None) == ()
E             
E             Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt')
E             
E             Full diff:
E             - ()
E             + (
E             +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'),
E             +     None,
E             + )
E           Kwargs:
E           assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E             
E             Omitting 3 identical items, use -vv to show
E             Right contains 2 more items:
E             {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw7/test_different_file_sizes_10_0/test_10mb.txt'),
E              'remote_path': None}
E             
E             Full diff:...
E             
E             ...Full output truncated (7 lines hidden), use '-vv' to show

tests/test_upload.py:608: AssertionError
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=1.26s, read=0.00s, upload=0.00s, validation=1.26s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: status 404
______________ TestCatboxProvider.test_catbox_auth_with_userhash _______________
[gw7] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestCatboxProvider object at 0x123899bb0>

    def test_catbox_auth_with_userhash(self):
        """Test Catbox provider with userhash."""
>       provider = catbox.CatboxProvider({"userhash": "test_hash"})

tests/test_upload.py:622: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <twat_fs.upload_providers.catbox.CatboxProvider object at 0x12392bc80>
args = ({'userhash': 'test_hash'},), kwargs = {}
cls = <class 'twat_fs.upload_providers.catbox.CatboxProvider'>
base = <class 'object'>, init = <slot wrapper '__init__' of 'object' objects>

    def _no_init_or_replace_init(self, *args, **kwargs):
        cls = type(self)
    
        if cls._is_protocol:
            raise TypeError('Protocols cannot be instantiated')
    
        # Already using a custom `__init__`. No need to calculate correct
        # `__init__` to call. This can lead to RecursionError. See bpo-45121.
        if cls.__init__ is not _no_init_or_replace_init:
            return
    
        # Initially, `__init__` of a protocol subclass is set to `_no_init_or_replace_init`.
        # The first instantiation of the subclass will call `_no_init_or_replace_init` which
        # searches for a proper new `__init__` in the MRO. The new `__init__`
        # replaces the subclass' old `__init__` (ie `_no_init_or_replace_init`). Subsequent
        # instantiation of the protocol subclass will thus use the new
        # `__init__` and no longer call `_no_init_or_replace_init`.
        for base in cls.__mro__:
            init = base.__dict__.get('__init__', _no_init_or_replace_init)
            if init is not _no_init_or_replace_init:
                cls.__init__ = init
                break
        else:
            # should not happen
            cls.__init__ = object.__init__
    
>       cls.__init__(self, *args, **kwargs)
E       TypeError: CatboxProvider.__init__() takes exactly one argument (the instance to initialize)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/typing.py:1792: TypeError
_______________ TestProviderSetup.test_setup_all_providers_check _______________
[gw2] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderSetup object at 0x11cfb9430>

    def test_setup_all_providers_check(self) -> None:
        """Test checking setup status for all providers."""
        results = setup_providers()
    
        # We can still test individual providers
        for provider in PROVIDERS_PREFERENCE:
            if provider.lower() == "simple":
                continue
            result = results[provider]
            # At least one provider should be available or have setup instructions
>           assert result.success or (
                "not configured" in result.explanation
                or "setup" in result.explanation.lower()
            )
E           assert (False or ('not configured' in "Provider 's3' needs configuration." or 'setup' in "provider 's3' needs configuration."))
E            +  where False = ProviderInfo(success=False, explanation="Provider 's3' needs configuration.", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).success
E            +  and   "Provider 's3' needs configuration." = ProviderInfo(success=False, explanation="Provider 's3' needs configuration.", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).explanation
E            +  and   "provider 's3' needs configuration." = <built-in method lower of str object at 0x11d41f050>()
E            +    where <built-in method lower of str object at 0x11d41f050> = "Provider 's3' needs configuration.".lower
E            +      where "Provider 's3' needs configuration." = ProviderInfo(success=False, explanation="Provider 's3' needs configuration.", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).explanation

tests/test_upload.py:215: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Failed to get account info: AuthError('9643cac3c3e049efa18edad3fcd971c8', AuthError('expired_access_token', None))
Error: Dropbox token has expired and cannot be refreshed automatically.
To enable automatic token refresh:
1. Set DROPBOX_REFRESH_TOKEN environment variable
2. Set DROPBOX_APP_KEY environment variable
For now, please generate a new access token.
------------------------------ Captured log call -------------------------------
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
INFO     dropbox:dropbox_client.py:488 ExpiredCredentials status_code=401: Refreshing and Retrying
WARNING  dropbox:dropbox_client.py:386 Unable to refresh access token without                 refresh token and app key
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
_____________________ TestEdgeCases.test_unicode_filename ______________________
[gw3] darwin -- Python 3.12.8 /usr/local/bin/python

self = <MagicMock name='get_provider().upload_file' id='4743211120'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), 'remote_path': None, 'unique': False, ...}
expected = call(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), remote_path=None, unique=False, force=False, upload_path=None)
actual = call(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), None, unique=False, force=False, upload_path=None)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x11ab3ed40>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), None, unique=False, force=False, upload_path=None)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:949: AssertionError

During handling of the above exception, another exception occurred:

self = <MagicMock name='get_provider().upload_file' id='4743211120'>, args = ()
kwargs = {'force': False, 'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), 'remote_path': None, 'unique': False, ...}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
E       AssertionError: expected call not found.
E       Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E         Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), None, unique=False, force=False, upload_path=None)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert (PosixPath('/...件.txt'), None) == ()
E         
E         Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt')
E         
E         Full diff:
E         - ()
E         + (
E         +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'),
E         +     None,
E         + )
E       Kwargs:
E       assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E         
E         Omitting 3 identical items, use -vv to show
E         Right contains 2 more items:
E         {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'),
E          'remote_path': None}
E         
E         Full diff:...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:961: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_upload.TestEdgeCases object at 0x11a95c350>
tmp_path = PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0')

    def test_unicode_filename(self, tmp_path: Path) -> None:
        """Test uploading a file with Unicode characters in the name."""
        test_file = tmp_path / "test_文件.txt"
        test_file.write_text("test content")
    
        with patch("twat_fs.upload_providers.s3.get_provider") as mock_provider:
            client = MagicMock()
            client.upload_file.return_value = TEST_URL
            mock_provider.return_value = client
    
            url = upload_file(test_file, provider="s3")
            assert url == TEST_URL
    
>           client.upload_file.assert_called_once_with(
                local_path=test_file,
                remote_path=None,
                unique=False,
                force=False,
                upload_path=None,
            )
E           AssertionError: expected call not found.
E           Expected: upload_file(local_path=PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), remote_path=None, unique=False, force=False, upload_path=None)
E             Actual: upload_file(PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'), None, unique=False, force=False, upload_path=None)
E           
E           pytest introspection follows:
E           
E           Args:
E           assert (PosixPath('/...件.txt'), None) == ()
E             
E             Left contains 2 more items, first extra item: PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt')
E             
E             Full diff:
E             - ()
E             + (
E             +     PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'),
E             +     None,
E             + )
E           Kwargs:
E           assert {'force': Fal...d_path': None} == {'force': Fal...': False, ...}
E             
E             Omitting 3 identical items, use -vv to show
E             Right contains 2 more items:
E             {'local_path': PosixPath('/private/var/folders/05/clcynl0509ldxltl599hhhx40000gn/T/pytest-of-adam/pytest-63/popen-gw3/test_unicode_filename0/test_文件.txt'),
E              'remote_path': None}
E             
E             Full diff:...
E             
E             ...Full output truncated (7 lines hidden), use '-vv' to show

tests/test_upload.py:544: AssertionError
----------------------------- Captured stdout call -----------------------------
Upload timing for s3: total=0.60s, read=0.00s, upload=0.00s, validation=0.59s
----------------------------- Captured stderr call -----------------------------
Error: URL validation failed: status 404
________________ TestProviderSetup.test_setup_invalid_provider _________________
[gw6] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderSetup object at 0x11fb37170>

    def test_setup_invalid_provider(self) -> None:
        """Test setup check for an invalid provider."""
        result = setup_provider("invalid")
        assert result.success is False
>       assert "Provider not found" in result.explanation
E       assert 'Provider not found' in "Provider 'invalid' is not available."
E        +  where "Provider 'invalid' is not available." = ProviderInfo(success=False, explanation="Provider 'invalid' is not available.", help_info={}, timing=None).explanation

tests/test_upload.py:114: AssertionError
___________ TestProviderSetup.test_setup_all_providers_with_failures ___________
[gw6] darwin -- Python 3.12.8 /usr/local/bin/python

self = <tests.test_upload.TestProviderSetup object at 0x11fb37890>

    def test_setup_all_providers_with_failures(self) -> None:
        """Test checking setup status when some providers fail."""
        with (
            patch("twat_fs.upload_providers.s3.get_credentials") as mock_s3_creds,
            patch(
                "twat_fs.upload_providers.dropbox.get_credentials"
            ) as mock_dropbox_creds,
            patch("twat_fs.upload_providers.fal.get_provider") as mock_fal_provider,
        ):
            # S3: Missing credentials
            mock_s3_creds.return_value = None
    
            # Dropbox: Has credentials but missing dependencies
            mock_dropbox_creds.return_value = {"access_token": "test"}
    
            # FAL: Has credentials and working
            mock_fal_provider.return_value = MagicMock()
    
            results = setup_providers()
    
            # Check S3 result (missing credentials)
            s3_result = results["s3"]
            assert s3_result.success is False
>           assert "not configured" in s3_result.explanation
E           assert 'not configured' in "Provider 's3' needs configuration."
E            +  where "Provider 's3' needs configuration." = ProviderInfo(success=False, explanation="Provider 's3' needs configuration.", help_info={'setup': "To use AWS S3 storage:\n1. Create an AWS account if you don't have one\n2. Create an S3 bucket to store your files\n3. Set up AWS credentials by either:\n   - Creating an IAM user and setting AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n   - Using AWS CLI: run 'aws configure'\n   - Setting up IAM roles if running on AWS infrastructure\n4. Set the following environment variables:\n   - AWS_S3_BUCKET: Name of your S3 bucket\n   - AWS_DEFAULT_REGION: AWS region (e.g. us-east-1)\n   Optional:\n   - AWS_ENDPOINT_URL: Custom S3 endpoint\n   - AWS_S3_PATH_STYLE: Set to 'true' for path-style endpoints\n   - AWS_ROLE_ARN: ARN of role to assume"}, timing=None).explanation

tests/test_upload.py:168: AssertionError
----------------------------- Captured stderr call -----------------------------
Error: Error setting up provider fal: type object 'MagicMock' has no attribute 'async_upload_file'
Error: Failed to get account info: AuthError('9828ca32da80417fac8d284d5d6e3d66', AuthError('expired_access_token', None))
Error: Dropbox token has expired and cannot be refreshed automatically.
To enable automatic token refresh:
1. Set DROPBOX_REFRESH_TOKEN environment variable
2. Set DROPBOX_APP_KEY environment variable
For now, please generate a new access token.
------------------------------ Captured log call -------------------------------
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account
INFO     dropbox:dropbox_client.py:488 ExpiredCredentials status_code=401: Refreshing and Retrying
WARNING  dropbox:dropbox_client.py:386 Unable to refresh access token without                 refresh token and app key
INFO     dropbox:dropbox_client.py:474 Request to users/get_current_account

---------- coverage: platform darwin, python 3.12.8-final-0 ----------
Name                                          Stmts   Miss Branch BrPart  Cover
-------------------------------------------------------------------------------
src/twat_fs/__init__.py                           5      0      0      0   100%
src/twat_fs/__main__.py                           1      1      0      0     0%
src/twat_fs/__version__.py                        9      9      0      0     0%
src/twat_fs/cli.py                              106     82     40      0    16%
src/twat_fs/upload.py                           262    134     82      7    47%
src/twat_fs/upload_providers/__init__.py         13      0      0      0   100%
src/twat_fs/upload_providers/async_utils.py      80      3     20      5    92%
src/twat_fs/upload_providers/bashupload.py       50     24      4      0    48%
src/twat_fs/upload_providers/catbox.py           44     19      0      0    57%
src/twat_fs/upload_providers/core.py            179     77     58     12    49%
src/twat_fs/upload_providers/dropbox.py         295    204     52      3    28%
src/twat_fs/upload_providers/factory.py          69     23     18      6    64%
src/twat_fs/upload_providers/fal.py              88     28     14      2    65%
src/twat_fs/upload_providers/filebin.py          73     11      6      1    82%
src/twat_fs/upload_providers/litterbox.py        98     28      8      2    70%
src/twat_fs/upload_providers/pixeldrain.py       78     16     12      3    74%
src/twat_fs/upload_providers/protocols.py        31      6      0      0    81%
src/twat_fs/upload_providers/s3.py               98     18     20      7    79%
src/twat_fs/upload_providers/simple.py           71     18     12      5    72%
src/twat_fs/upload_providers/types.py            11      0      0      0   100%
src/twat_fs/upload_providers/uguu.py             48     21      2      0    54%
src/twat_fs/upload_providers/utils.py            84      0     30      2    98%
src/twat_fs/upload_providers/www0x0.py           47     20      2      0    55%
tests/__init__.py                                 0      0      0      0   100%
tests/test_async_utils.py                       155      4      8      0    98%
tests/test_filebin_pixeldrain.py                 49      0      0      0   100%
tests/test_integration.py                       133     52     14      4    61%
tests/test_s3_advanced.py                       136     50      0      0    63%
tests/test_twat_fs.py                             3      0      0      0   100%
tests/test_upload.py                            370     88      4      2    76%
tests/test_utils.py                             169      2      2      1    98%
-------------------------------------------------------------------------------
TOTAL                                          2855    938    408     62    64%

============================= slowest 10 durations =============================
6.02s call     tests/test_filebin_pixeldrain.py::test_filebin_upload_failure
6.02s call     tests/test_filebin_pixeldrain.py::test_pixeldrain_upload_failure
3.77s call     tests/test_upload.py::black
3.19s call     tests/test_twat_fs.py::black
2.92s call     tests/test_s3_advanced.py::black
2.82s call     tests/test_utils.py::black
2.76s call     tests/test_integration.py::black
2.76s call     tests/test_async_utils.py::black
2.68s call     tests/test_filebin_pixeldrain.py::black
2.60s call     tests/__init__.py::black
=========================== short test summary info ============================
FAILED tests/test_integration.py::TestCatboxIntegration::test_catbox_setup - ...
FAILED tests/test_integration.py::TestLitterboxIntegration::test_litterbox_setup
FAILED tests/test_s3_advanced.py::ruff - pytest_ruff.RuffError: tests/test_s3...
FAILED tests/test_integration.py::TestDropboxIntegration::test_dropbox_setup
FAILED tests/test_s3_advanced.py::TestS3Configurations::test_custom_endpoint
FAILED tests/test_s3_advanced.py::TestS3Configurations::test_path_style_endpoint
FAILED tests/test_s3_advanced.py::TestS3Configurations::test_custom_region_endpoint
FAILED tests/test_s3_advanced.py::TestS3MultipartUploads::test_multipart_upload
FAILED tests/test_integration.py::TestDropboxIntegration::test_dropbox_upload_small_file
FAILED tests/test_s3_advanced.py::TestS3MultipartUploads::test_multipart_upload_failure
FAILED tests/test_integration.py::TestDropboxIntegration::test_dropbox_upload_large_file
FAILED tests/test_upload.py::ruff - pytest_ruff.RuffError: tests/test_upload....
FAILED tests/test_integration.py::TestFalIntegration::test_fal_setup - TypeEr...
FAILED tests/test_integration.py::TestFalIntegration::test_fal_upload_small_file
FAILED tests/test_integration.py::TestFalIntegration::test_fal_upload_large_file
FAILED tests/test_upload.py::TestProviderSetup::test_setup_provider_success
FAILED tests/test_upload.py::TestProviderSetup::test_setup_provider_failure
FAILED tests/test_upload.py::TestProviderAuth::test_s3_auth_with_credentials
FAILED tests/test_upload.py::TestProviderAuth::test_s3_auth_with_invalid_credentials
FAILED tests/test_s3_advanced.py::TestAwsCredentialProviders::test_environment_credentials
FAILED tests/test_s3_advanced.py::TestAwsCredentialProviders::test_shared_credentials_file
FAILED tests/test_s3_advanced.py::TestAwsCredentialProviders::test_assume_role
FAILED tests/test_upload.py::TestUploadFile::test_upload_with_s3_provider - A...
FAILED tests/test_upload.py::TestUploadFile::test_s3_upload_failure - Failed:...
FAILED tests/test_integration.py::TestSetupIntegration::test_setup_all_providers
FAILED tests/test_upload.py::TestProviderSetup::test_setup_provider_dropbox
FAILED tests/test_upload.py::TestUploadFile::test_upload_with_provider_list
FAILED tests/test_upload.py::TestEdgeCases::test_no_read_permission - Failed:...
FAILED tests/test_upload.py::TestEdgeCases::test_empty_file - AssertionError:...
FAILED tests/test_upload.py::TestEdgeCases::test_very_long_filename - OSError...
FAILED tests/test_upload.py::TestUploadFile::test_upload_with_default_provider
FAILED tests/test_upload.py::TestUploadFile::test_all_providers_fail - Failed...
FAILED tests/test_upload.py::TestCatboxProvider::test_catbox_auth_without_userhash
FAILED tests/test_twat_fs.py::black
FAILED tests/test_upload.py::TestUploadFile::test_upload_with_specific_provider
FAILED tests/test_upload.py::TestCatboxProvider::test_catbox_upload_file - As...
FAILED tests/test_upload.py::TestCatboxProvider::test_catbox_upload_url - Typ...
FAILED tests/test_upload.py::TestProviderSetup::test_setup_working_provider
FAILED tests/test_upload.py::TestProviderSetup::test_setup_missing_credentials
FAILED tests/test_upload.py::TestLitterboxProvider::test_litterbox_upload_file
FAILED tests/test_upload.py::TestProviderSetup::test_setup_missing_dependencies
FAILED tests/test_upload.py::test_fragile_mode - Failed: DID NOT RAISE <class...
FAILED tests/test_upload.py::TestEdgeCases::test_different_file_sizes[1] - As...
FAILED tests/test_utils.py::ruff - pytest_ruff.RuffError: tests/test_utils.py...
FAILED tests/test_upload.py::TestEdgeCases::test_special_characters_in_filename
FAILED tests/test_upload.py::TestEdgeCases::test_different_file_sizes[5] - As...
FAILED tests/test_upload.py::TestEdgeCases::test_different_file_sizes[10] - A...
FAILED tests/test_upload.py::TestCatboxProvider::test_catbox_auth_with_userhash
FAILED tests/test_upload.py::TestProviderSetup::test_setup_all_providers_check
FAILED tests/test_upload.py::TestEdgeCases::test_unicode_filename - Assertion...
FAILED tests/test_upload.py::TestProviderSetup::test_setup_invalid_provider
FAILED tests/test_upload.py::TestProviderSetup::test_setup_all_providers_with_failures
ERROR tests/test_integration.py::TestLitterboxIntegration::test_litterbox_upload_small_file
ERROR tests/test_integration.py::TestLitterboxIntegration::test_litterbox_upload_large_file
ERROR tests/test_integration.py::TestLitterboxIntegration::test_litterbox_different_expirations
ERROR tests/test_integration.py::TestCatboxIntegration::test_catbox_upload_small_file
ERROR tests/test_integration.py::TestCatboxIntegration::test_catbox_upload_large_file
ERROR tests/test_upload.py::TestUploadFile::test_upload_fallback_on_upload_failure
ERROR tests/test_upload.py::TestUploadFile::test_upload_fallback_on_auth_failure
ERROR tests/test_upload.py::test_circular_fallback - AttributeError: <module ...
ERROR tests/test_upload.py::test_custom_provider_list_circular_fallback - Att...
ERROR tests/test_upload.py::TestProviderSetup::test_setup_all_providers - Att...
======== 52 failed, 83 passed, 5 skipped, 10 errors in 75.63s (0:01:15) ========

2025-03-04 07:21:06 - All checks completed
2025-03-04 07:21:06 - 
=== TODO.md ===
2025-03-04 07:21:06 - ---
this_file: TODO.md
---

# TODO

Tip: Periodically run `python ./cleanup.py status` to see results of lints and tests. Use `uv pip ...` not `pip ...`


## Phase 1

- [ ] Fix failing unit tests
  - [x] Fix `TestCreateProviderInstance` tests
  - [x] Fix `TestGatherWithConcurrency` tests
  - [ ] Fix `TestLogUploadAttempt.test_log_upload_attempt_success` test
    - Issue: logger.info is not being called in the log_upload_attempt function
    - Fix: Implement proper logger.info call in the success branch
  - [ ] Fix `TestGatherWithConcurrency.test_gather_with_concurrency_with_exceptions` test
    - Issue: Test is failing with RuntimeError instead of ValueError
    - Fix: Ensure the correct exception type is propagated in gather_with_concurrency
- [ ] Fix boolean argument issues in `utils.py`
  - [ ] Fix FBT001 linter error in `utils.py` line 251
    - Issue: Boolean-typed positional argument in function definition
    - Fix: Convert boolean positional arguments to keyword-only arguments
  - [ ] Refactor functions with too many arguments
    - Use keyword-only arguments for optional parameters
    - Group related parameters into dataclasses or TypedDict
- [ ] Fix type annotation issues
  - [ ] Fix missing imports for `aiohttp` and `loguru`
  - [ ] Fix unknown attribute error for `Response.status`
  - [ ] Add proper type hints for HTTP response objects

## Phase 2

- [ ] Fix exception handling issues
  - [ ] Implement consistent error handling patterns
  - [ ] Add proper error context in exception messages
  - [ ] Use custom exception types for specific error scenarios
- [ ] Fix linter issues in `cleanup.py`
  - [ ] Address unused imports
  - [ ] Fix function complexity issues
  - [ ] Improve error handling
- [ ] Update `pyproject.toml` to fix deprecated linter settings
  - [ ] Update ruff configuration
  - [ ] Add explicit Python version targets
  - [ ] Configure mypy settings

## Phase 3

- [ ] Improve code quality and maintainability
  - [ ] Reduce function complexity
  - [ ] Add comprehensive docstrings
  - [ ] Implement consistent logging patterns
- [ ] Enhance test coverage
  - [ ] Add tests for edge cases
  - [ ] Implement integration tests for providers
  - [ ] Add performance benchmarks

## Medium Priority

- [ ] Refine HTTP response handling
  - [ ] Standardize response parsing across providers
  - [ ] Improve error message extraction
- [ ] Fix function complexity issues
  - [ ] Break down complex functions into smaller, focused functions
  - [ ] Extract reusable utility functions
- [ ] Document best practices for creating new providers
  - [ ] Create comprehensive provider development guide
  - [ ] Add examples for common provider patterns
- [ ] Fix unused arguments and imports
  - [ ] Remove dead code
  - [ ] Consolidate duplicate functionality

## New Providers

- [ ] Add support for Imgur
- [ ] Add support for Cloudinary
- [ ] Add support for Google Drive
- [ ] Add support for OneDrive
- [ ] Add support for Box
- [ ] Add support for Mega
- [ ] Add support for Backblaze B2
- [ ] Add support for Wasabi

## Completed Tasks

- [x] Fix `TestCreateProviderInstance` tests
- [x] Fix `TestGatherWithConcurrency` tests
- [x] Create `utils.py` module for shared functionality
- [x] Refactor provider modules to use `utils.py`
- [x] Create provider templates
- [x] Implement factory pattern for provider instantiation
- [x] Standardize async/sync conversion patterns
- [x] Write unit tests for utility functions
- [x] Create provider base classes
2025-03-04 07:21:06 -  M .cursor/rules/filetree.mdc
 M .specstory/history/2025-03-04_06-19-implementation-of-todo-md-phases.md
 M CHANGELOG.md
 M CLEANUP.txt
 M README.md
 M TODO.md
 M cleanup.py
 M src/twat_fs/upload_providers/async_utils.py
 M tests/test_async_utils.py
 D twat_search.txt
?? .specstory/history/2025-03-04_07-52-untitled.md
?? .specstory/history/2025-03-04_07-59-project-maintenance-and-documentation-update.md
?? REPO_CONTENT.txt

2025-03-04 07:21:06 - Changes detected in repository
